<html><head><title>Smooth Data Using a Directly Specified Roughness Penalty</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>smooth.basisPar(fda)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   smooth.basisPar">
<param name="keyword" value=" Smooth Data Using a Directly Specified Roughness Penalty">
</object>


<h2>Smooth Data Using a Directly Specified Roughness Penalty</h2>


<h3>Description</h3>

<p>
Smooth (argvals, y) data with roughness penalty defined by the
remaining arguments.
</p>


<h3>Usage</h3>

<pre>
smooth.basisPar(argvals, y, fdobj=NULL, Lfdobj=NULL,
      lambda=0, estimate=TRUE, penmat=NULL,
      wtvec=rep(1, length(argvals)), fdnames=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>argvals</code></td>
<td>
a vector of argument values correspond to the observations in array
<code>y</code>.
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
an array containing values of curves at discrete sampling points or
argument values. If the array is a matrix, the rows must correspond
to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
<code>y</code> is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.  If <code>y</code> is a vector,
only one replicate and variable are assumed.  
</td></tr>
<tr valign="top"><td><code>fdobj</code></td>
<td>
One of the following:
<br>
<ul>
<dt>fd</dt><dd>a functional data object (class <code>fd</code>)</dd>
<dt>basisfd</dt><dd>a functional basis object (class <code>basisfd</code>, which is
converted to a functional data object with the identity matrix
as the coefficient matrix. 
</dd>
<dt>fdPar</dt><dd>a functional parameter object (class <code>fdPar</code>)
</dd>
<dt>integer</dt><dd>an integer giving the order of a B-spline basis, which is
further converted to a functional data object with the identity
matrix as the coefficient matrix.  
</dd>
<dt>matrix or array</dt><dd>replaced by fd(fdobj)</dd>     
<dt>NULL</dt><dd>Defaults to fdobj = create.bspline.basis(argvals).
</dd>
</ul>
</td></tr>
<tr valign="top"><td><code>Lfdobj</code></td>
<td>
either a nonnegative integer or a linear differential operator
object.  If NULL and fdobj[['type']] == 'bspline', Lfdobj =
int2Lfd(max(0, norder-2)), where norder = order of fdobj.   
</td></tr>
<tr valign="top"><td><code>lambda</code></td>
<td>
a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.
</td></tr>
<tr valign="top"><td><code>estimate</code></td>
<td>
a logical value:  if <code>TRUE</code>, the functional parameter is
estimated, otherwise, it is held fixed.
</td></tr>
<tr valign="top"><td><code>penmat</code></td>
<td>
a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.
</td></tr>
<tr valign="top"><td><code>wtvec</code></td>
<td>
a vector of the same length as <code>argvals</code> containing weights for
the values to be smoothed. 
</td></tr>
<tr valign="top"><td><code>fdnames</code></td>
<td>
a list of length 3 containing character vectors of names for the
following: 
<br>
<ul>
<dt>args</dt><dd>name for each observation or point in time at which data are
collected for each 'rep', unit or subject.
</dd>
<dt>reps</dt><dd>name for each 'rep', unit or subject.
</dd>
<dt>fun</dt><dd>name for each 'fun' or (response) variable measured repeatedly
(per 'args') for each 'rep'.
</dd>
</ul>
</td></tr>
</table>

<h3>Details</h3>

<p>
1.  if(is.null(fdobj))fdobj &lt;- create.bspline.basis(argvals).  Else
if(is.integer(fdobj)) fdobj &lt;- create.bspline.basis(argvals, norder =
fdobj) 
</p>
<p>
2.  fdPar
</p>
<p>
3.  smooth.basis
</p>


<h3>Value</h3>

<p>
The output of a call to 'smooth.basis', which is a named list of
length 6 and class <code>fdSmooth</code> with the following components:  
</p>
<table summary="R argblock">
<tr valign="top"><td><code>fd</code></td>
<td>
a functional data object that smooths the data.
</td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
a degrees of freedom measure of the smooth
</td></tr>
<tr valign="top"><td><code>gcv</code></td>
<td>
the value of the generalized cross-validation or GCV criterion.  If
there are multiple curves, this is a vector of values, one per
curve.  If the smooth is multivariate, the result is a matrix of gcv
values, with columns corresponding to variables.  
</td></tr>
<tr valign="top"><td><code>SSE</code></td>
<td>
the error sums of squares.  SSE is a vector or a matrix of the same
size as 'gcv'. 
</td></tr>
<tr valign="top"><td><code>penmat</code></td>
<td>
the penalty matrix.
</td></tr>
<tr valign="top"><td><code>y2cMap</code></td>
<td>
the matrix mapping the data to the coefficients.
</td></tr>
</table>

<h3>References</h3>

<p>
Ramsay, James O., and Silverman, Bernard W. (2005), <EM>Functional 
Data Analysis, 2nd ed.</EM>, Springer, New York. 
</p>
<p>
Ramsay, James O., and Silverman, Bernard W. (2002), <EM>Applied
Functional Data Analysis</EM>, Springer, New York.
</p>


<h3>See Also</h3>

<p>
<code><a href="Data2fd.html">Data2fd</a></code>, 
<code><a href="df2lambda.html">df2lambda</a></code>, 
<code><a href="fdPar.html">fdPar</a></code>, 
<code><a href="lambda2df.html">lambda2df</a></code>, 
<code><a href="lambda2gcv.html">lambda2gcv</a></code>, 
<code><a href="plot.fd.html">plot.fd</a></code>, 
<code><a href="project.basis.html">project.basis</a></code>, 
<code><a href="smooth.basis.html">smooth.basis</a></code>, 
<code><a href="smooth.fd.html">smooth.fd</a></code>, 
<code><a href="smooth.monotone.html">smooth.monotone</a></code>, 
<code><a href="smooth.pos.html">smooth.pos</a></code>
</p>


<h3>Examples</h3>

<pre>
##
## simplest call
##
girlGrowthSm &lt;- with(growth, smooth.basisPar(argvals=age, y=hgtf))
plot(girlGrowthSm$fd, xlab="age", ylab="height (cm)",
         main="Girls in Berkeley Growth Study" )
plot(deriv(girlGrowthSm$fd), xlab="age", ylab="growth rate (cm / year)",
         main="Girls in Berkeley Growth Study" )
plot(deriv(girlGrowthSm$fd, 2), xlab="age",
        ylab="growth acceleration (cm / year^2)",
        main="Girls in Berkeley Growth Study" )
#  Shows the effects of smoothing
#  where the size of the third derivative is penalized.
#  The null space contains quadratic functions.

##
## Another simple call
##
lipSm &lt;- smooth.basisPar(liptime, lip)
plot(lipSm)
# oversmoothing
plot(smooth.basisPar(liptime, lip, lambda=1e-9))
# more sensible 

##
## A third example 
##

x &lt;- seq(-1,1,0.02)
y &lt;- x + 3*exp(-6*x^2) + sin(1:101)/2
# sin not rnorm to make it easier to compare
# results across platforms 

#  set up a saturated B-spline basis
basisobj101 &lt;- create.bspline.basis(x)
fdParobj101 &lt;- fdPar(basisobj101, 2, lambda=1)
result101  &lt;- smooth.basis(x, y, fdParobj101)

resultP &lt;- smooth.basisPar(argvals=x, y=y, fdobj=basisobj101, lambda=1)

all.equal(result101, resultP)

# TRUE 

result4 &lt;- smooth.basisPar(argvals=x, y=y, fdobj=4, lambda=1)

all.equal(resultP, result4)

# TRUE 

result4. &lt;- smooth.basisPar(argvals=x, y=y, lambda=1)

all.equal(resultP, result4.)

# TRUE

with(result4, c(df, gcv)) #  display df and gcv measures

result4.4 &lt;- smooth.basisPar(argvals=x, y=y, lambda=1e-4)
with(result4.4, c(df, gcv)) #  display df and gcv measures
# less smoothing, more degrees of freedom, better fit 

plot(result4.4)
lines(result4, col='green')
lines(result4$fd, col='green') # same as lines(result4, ...)

result4.0 &lt;- smooth.basisPar(x, y, basisobj101, lambda=0)

result4.0a &lt;- smooth.basisPar(x, y, lambda=0)

all.equal(result4.0, result4.0a)


with(result4.0, c(df, gcv)) #  display df and gcv measures
# no smoothing, degrees of freedom = number of points 
# but generalized cross validation = Inf
# suggesting overfitting.  

##
## fdnames?
##
girlGrow12 &lt;- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
              fdnames=c('age', 'girl', 'height')) ) 
girlGrow12. &lt;- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
    fdnames=list(age=age, girl=c('Carol', 'Sally'), value='height')) )

</pre>



<hr><div align="center">[Package <em>fda</em> version 2.0.0 <a href="00Index.html">Index]</a></div>

</body></html>
