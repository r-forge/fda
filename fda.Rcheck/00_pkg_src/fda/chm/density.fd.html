<html><head><title>Compute a Probability Density Function</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>density.fd(fda)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   density.fd">
<param name="keyword" value=" Compute a Probability Density Function">
</object>


<h2>Compute a Probability Density Function</h2>


<h3>Description</h3>

<p>
Like the regular S-PLUS function <code>density</code>, this function
computes a probability density function for a sample of values of a
random variable.  However, in this case the density function is defined
by a functional parameter object <code>WfdParobj</code> along with a normalizing
constant <code>C</code>.
</p>
<p>
The density function $p(x)$ has the form
<code>p(x) = C exp[W(x)]</code>
where function $W(x)$ is defined by the functional data object
<code>WfdParobj</code>.
</p>


<h3>Usage</h3>

<pre>
density.fd(x, WfdParobj, conv=0.0001, iterlim=20,
           active=2:nbasis, dbglev=1, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
a strictly increasing set variable values.
These observations may be one of two forms:
<ol>
<li>a vector of observatons $x_i$
<li>a two-column matrix, with the observations $x_i$ in the
first column, and frequencies $f_i$ in the second.
</ol>
The first option corresponds to all $f_i = 1$.
</td></tr>
<tr valign="top"><td><code>WfdParobj</code></td>
<td>
a functional parameter object specifying the initial
value, basis object, roughness penalty and smoothing
parameter defining function $W(t).$
</td></tr>
<tr valign="top"><td><code>conv</code></td>
<td>
a positive constant defining the convergence criterion.
</td></tr>
<tr valign="top"><td><code>iterlim</code></td>
<td>
the maximum number of iterations allowed.
</td></tr>
<tr valign="top"><td><code>active</code></td>
<td>
a logical vector of length equal to the number of coefficients
defining <code>Wfdobj</code>. If an entry is TRUE, the corresponding
coefficient is estimated, and if FALSE, it is held at the value defining the
argument <code>Wfdobj</code>.  Normally the first coefficient is set to 0
and not estimated, since it is assumed that $W(0) = 0$.
</td></tr>
<tr valign="top"><td><code>dbglev</code></td>
<td>
either 0, 1, or 2.  This controls the amount information printed out on
each iteration, with 0 implying no output, 1 intermediate output level,
and 2 full output.  If levels 1 and 2 are used, it is helpful to
turn off the output buffering option in S-PLUS.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Other arguments to match the generic function 'density'</td></tr>
</table>

<h3>Details</h3>

<p>
The goal of the function is provide a smooth density function
estimate that approaches some target density by an amount that is
controlled by the linear differential operator <code>Lfdobj</code> and
the penalty parameter. For example, if the second derivative of
$W(t)$ is penalized heavily, this will force the function to
approach a straight line, which in turn will force the density function
itself to be nearly normal or Gaussian.  Similarly, to each textbook
density function there corresponds a $W(t)$, and to each of these
in turn their corresponds a linear differential operator that will, when
apply to $W(t)$, produce zero as a result.
To plot the density function or to evaluate it, evaluate <code>Wfdobj</code>,
exponentiate the resulting vector, and then divide by the normalizing
constant <code>C</code>.
</p>


<h3>Value</h3>

<p>
a named list of length 4 containing:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>Wfdobj</code></td>
<td>
a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the monotone function that it defines.
</td></tr>
<tr valign="top"><td><code>C</code></td>
<td>
the normalizing constant.
</td></tr>
<tr valign="top"><td><code>Flist</code></td>
<td>
a named list containing three results for the final converged solution:
(1)
<B>f</B>: the optimal function value being minimized,
(2)
<B>grad</B>: the gradient vector at the optimal solution,   and
(3)
<B>norm</B>: the norm of the gradient vector at the optimal solution.
</td></tr>
<tr valign="top"><td><code>iternum</code></td>
<td>
the number of iterations.
</td></tr>
<tr valign="top"><td><code>iterhist</code></td>
<td>
a <code>iternum+1</code> by 5 matrix containing the iteration
history.
</td></tr>
</table>

<h3>See Also</h3>

<p>
<code><a href="intensity.fd.html">intensity.fd</a></code>
<code><a onclick="findlink('stats', 'density.html')" style="text-decoration: underline; color: blue; cursor: hand">density</a></code>
</p>


<h3>Examples</h3>

<pre>

#  set up range for density
rangeval &lt;- c(-3,3)
#  set up some standard normal data
x &lt;- rnorm(50)
#  make sure values within the range
x[x &lt; -3] &lt;- -2.99
x[x &gt;  3] &lt;-  2.99
#  set up basis for W(x)
basisobj &lt;- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 &lt;- fd(matrix(0,11,1), basisobj)
WfdParobj &lt;- fdPar(Wfd0)
#  estimate density
denslist &lt;- density.fd(x, WfdParobj)
#  plot density
xval &lt;- seq(-3,3,.2)
wval &lt;- eval.fd(xval, denslist$Wfdobj)
pval &lt;- exp(wval)/denslist$C
plot(xval, pval, type="l", ylim=c(0,0.4))
points(x,rep(0,50))

</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>fda</em> version 2.0.5 <a href="00Index.html">Index]</a></div>

</body></html>
