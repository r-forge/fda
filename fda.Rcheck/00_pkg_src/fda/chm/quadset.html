<html><head><title>Quadrature points and weights for Simpson's rule</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>quadset(fda)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   quadset">
<param name="keyword" value=" Quadrature points and weights for Simpson's rule">
</object>


<h2>Quadrature points and weights for Simpson's rule</h2>


<h3>Description</h3>

<p>
Set up quadrature points and weights for Simpson's rule.
</p>


<h3>Usage</h3>

<pre>
quadset(nquad=5, basisobj=NULL, breaks) 
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>nquad</code></td>
<td>
an odd integer at least 5 giving the number of evenly spaced
Simpson's rule quadrature points to use over each interval
(breaks[i], breaks[i+1]). 
</td></tr>
<tr valign="top"><td><code>basisobj</code></td>
<td>
the basis object that will contain the quadrature points and weights
</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
optional interval boundaries.  If this is provided, the first value
must be the initial point of the interval over which the basis is
defined, and the final value must be the end point.  If this is not
supplied, and 'basisobj' is of type 'bspline', the knots are used as
these values.
</td></tr>
</table>

<h3>Details</h3>

<p>
Set up quadrature points and weights for Simpson's rule and store
information in the output 'basisobj'.  Simpson's rule is used to
integrate a function between successive values in vector 'breaks'.
That is, over each interval (breaks[i], breaks[i+1]).  Simpson's rule
uses 'nquad' equally spaced quadrature points over this interval,
starting with the the left boundary and ending with the right
boundary.  The quadrature weights are the values
delta*c(1,4,2,4,2,4,..., 2,4,1) where 'delta' is the difference
between successive quadrature points, that is, delta =
(breaks[i-1]-breaks[i])/(nquad-1).
</p>


<h3>Value</h3>

<p>
If is.null(basisobj), quadset returns a 'quadvals' matrix with columns
quadpts and quadwts.  Otherwise, it returns basisobj with the
two components set as follows:   
</p>
<table summary="R argblock">
<tr valign="top"><td><code>quadvals</code></td>
<td>
cbind(quadpts=quadpts, quadwts=quadwts)    
</td></tr>
<tr valign="top"><td><code>value</code></td>
<td>
a list with two components containing eval.basis(quadpts, basisobj,
ival-1) for ival=1, 2.  
</td></tr>
</table>

<h3>See Also</h3>

<p>
<code><a href="create.bspline.basis.html">create.bspline.basis</a></code>
<code><a href="eval.basis.html">eval.basis</a></code>
</p>


<h3>Examples</h3>

<pre>
(qs7.1 &lt;- quadset(nquad=7, breaks=c(0, .3, 1)))
# cbind(quadpts=c(seq(0, 0.3, length=7),
#              seq(0.3, 1, length=7)), 
#    quadwts=c((0.3/18)*c(1, 4, 2, 4, 2, 4, 1),
#              (0.7/18)*c(1, 4, 2, 4, 2, 4, 1) ) )

# The simplest basis currently available with this function:
bspl2.2 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))

bspl2.2a &lt;- quadset(basisobj=bspl2.2)
bspl2.2a$quadvals
# cbind(quadpts=c((0:4)/8, .5+(0:4)/8),
#       quadwts=rep(c(1,4,2,4,1)/24, 2) )
bspl2.2a$values
# a list of length 2
# [[1]] = matrix of dimension c(10, 3) with the 3 basis 
#      functions evaluated at the 10 quadrature points:
# values[[1]][, 1] = c(1, .75, .5, .25, rep(0, 6))
# values[[1]][, 2] = c(0, .25, .5, .75, 1, .75, .5, .25, 0)
# values[[1]][, 3] = values[10:1, 1]
#
# values[[2]] = matrix of dimension c(10, 3) with the
#     first derivative of values[[1]], being either 
#    -2, 0, or 2.  
</pre>



<hr><div align="center">[Package <em>fda</em> version 2.0.5 <a href="00Index.html">Index]</a></div>

</body></html>
