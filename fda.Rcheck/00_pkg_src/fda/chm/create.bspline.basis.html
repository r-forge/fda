<html><head><title>Create a B-spline Basis</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>create.bspline.basis(fda)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   create.bspline.basis">
<param name="keyword" value=" Create a B-spline Basis">
</object>


<h2>Create a B-spline Basis</h2>


<h3>Description</h3>

<p>
Functional data objects are constructed by specifying a set of basis 
functions and a set of coefficients defining a linear combination of
these basis functions.  The B-spline basis is a system that is usually
used for non-periodic functions.  It has the advantages of very fast
computation and great flexibility.  On the other hand, if the data are
considered to be periodic, then the Fourier basis is usually
preferred.
</p>


<h3>Usage</h3>

<pre>
create.bspline.basis(rangeval=NULL, nbasis=NULL, norder=4,
      breaks=NULL, dropind=NULL, quadvals=NULL, values=NULL,
      names="bspl") 
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>rangeval</code></td>
<td>
a numeric vector of length 2 defining the interval over
which the functional data object can be evaluated;  default value
is if(is.null(breaks)) 0:1 else range(breaks).  
<br>
If length(rangeval) == 1 and rangeval &lt;= 0, this is an error.
Otherwise, if length(rangeval) == 1, rangeval is replaced by c(0,
rangeval).  
<br>
If length(rangeval)&gt;2 and neither <code>breaks</code> nor <code>nbasis</code>
are provided, this extra long <code>rangeval</code> argument is assigned
to <code>breaks</code>, and then rangeval = range(breaks).  
</td></tr>
<tr valign="top"><td><code>nbasis</code></td>
<td>
an integer variable specifying the number of basis functions.
Default value NULL.
<br>
This 'nbasis' argument is ignored if 'breaks' is supplied, in which
case nbasis = nbreaks + norder - 2, where nbreaks = length(breaks).
</td></tr>
<tr valign="top"><td><code>norder</code></td>
<td>
an integer specifying the order of b-splines, which is one higher
than their degree. The default of 4 gives cubic splines.
</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
a vector specifying the break points defining the b-spline.
Also called knots, these are a strictly increasing sequence
of junction points between piecewise polynomial segments.
They must satisfy <code>breaks[1] = rangeval[1]</code> and
<code>breaks[nbreaks] = rangeval[2]</code>, where <code>nbreaks</code> is the 
length of <code>breaks</code>.  There must be at least 2 values in
<code>breaks</code>.  There is a potential for inconsistency among
arguments <code>nbasis</code>, <code>norder</code>, and <code>breaks</code>.  It is
resolved as follows:
<br>
If <code>breaks</code> is supplied, <code>nbreaks = length(breaks)</code>, and
<code>nbasis = nbreaks + norder - 2</code>, no matter what value for
<code>nbasis</code> is supplied. 
<br>
If <code>breaks</code> is not supplied, but <code>nbasis</code> is,
<code>nbreaks = nbasis - norder + 2</code>, and if this turns out to be
less than 2, an error message results.
<br>
If neither <code>breaks</code> nor <code>nbasis</code> is supplied,
<code>nbreaks</code> is set to 21.
<br>
If <code>breaks</code> is not provided, it is set to seq(rangeval[1],
rangeval[2], length=nbreaks).  
</td></tr>
<tr valign="top"><td><code>dropind</code></td>
<td>
a vector of integers specifiying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point. Default value NULL.
</td></tr>
<tr valign="top"><td><code>quadvals</code></td>
<td>
a matrix with two columns and a number of rows equal to the number 
of argument values used to approximate an integral using Simpson's
rule.  The first column contains these argument values.
A minimum of 5 values are required for
each inter-knot interval, and that is often enough. These
are equally spaced between two adjacent knots.
The second column contains the weights used for Simpson's
rule.  These are proportional to 1, 4, 2, 4, ..., 2, 4, 1.
</td></tr>
<tr valign="top"><td><code>values</code></td>
<td>
a list containing the basis functions and their derivatives
evaluated at the quadrature points contained in the first
column of <code> quadvals </code>.
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
either a character vector of the same length as the number of basis 
functions or a single character string to which norder, "." and
1:nbasis are appended as paste(names, norder, ".", 1:nbreaks,
sep="").  For example, if norder = 4, this defaults to 'bspl4.1',
'bspl4.2', ... .   
</td></tr>
</table>

<h3>Details</h3>

<p>
Spline functions are constructed by joining polynomials end-to-end at
argument values called <EM>break points</EM> or <EM>knots</EM>. First, the
interval is subdivided into a set of adjoining intervals
separated the knots.  Then a polynomial of order $m$ and
degree $m-1$ is defined for each interval.  In order to make the
resulting piece-wise polynomial smooth, two adjoining polynomials are
constrained to have their values and all their derivatives up to order
$m-2$ match at the point where they join.
</p>
<p>
Consider as an illustration the very common case where the order is 4 
for all polynomials, so that degree of each polynomials is 3.  That
is, the polynomials are <EM>cubic</EM>.  Then at each break point or
knot, the values of adjacent polynomials must match, and so also for
their first and second derivatives.  Only their third derivatives will
differ at the point of junction.
</p>
<p>
The number of degrees of freedom of a cubic spline function of this
nature is calculated as follows.  First, for the first interval, there
are four degrees of freedom.  Then, for each additional interval, the
polynomial over that interval now has only one degree of freedom
because of the requirement for matching values and derivatives.  This
works out to the following equation:  The number of degrees of freedom
is equal to the number of interior knots (that is, not counting the
lower and upper limits) plus the order of the polynomials.
</p>
<p>
<EM>B-splines</EM> are a set of special spline functions that can be
used to construct any such piece-wise polynomial by computing the
appropriate linear combination.  They derive their computational
convience from the fact that any B-spline basis function is nonzero
over at most m adjacent intervals.  The number of basis functions is
given by the rule above for the number of degrees of freedom.
</p>
<p>
The number of intervals controls the flexibility of the spline;  the
more knots, the more flexible the resulting spline will be. But the 
position of the knots also plays a role.  Where do we position the
knots?  There is room for judgment here, but two considerations must
be kept in mind:  (1) you usually want at least one argument value
between two adjacent knots, and (2)  there should be more knots where
the curve needs to have sharp curvatures such as a sharp peak or
valley or an abrupt change of level, but only a few knots are required
where the curve is changing very slowly.
</p>
<p>
This function automatically includes norder replicates of the end
points rangeval.  By contrast, the analogous splines' package
functions <a onclick="findlink('splines', 'splineDesign.html')" style="text-decoration: underline; color: blue; cursor: hand">splineDesign</a> and <a onclick="findlink('splines', 'spline.des.html')" style="text-decoration: underline; color: blue; cursor: hand">spline.des</a>
do NOT automatically replicate the end points.  To compare answers,
the end knots must be replicated manually when using
<a onclick="findlink('splines', 'splineDesign.html')" style="text-decoration: underline; color: blue; cursor: hand">splineDesign</a> or <a onclick="findlink('splines', 'spline.des.html')" style="text-decoration: underline; color: blue; cursor: hand">spline.des</a>.
</p>


<h3>Value</h3>

<p>
a basis object of the type <code>bspline</code></p>

<h3>References</h3>

<p>
Ramsay, James O., and Silverman, Bernard W. (2005), <EM>Functional 
Data Analysis, 2nd ed.</EM>, Springer, New York. 
</p>
<p>
Ramsay, James O., and Silverman, Bernard W. (2002), <EM>Applied
Functional Data Analysis</EM>, Springer, New York.
</p>


<h3>See Also</h3>

<p>
<code><a href="basisfd.html">basisfd</a></code>, 
<code><a href="create.constant.basis.html">create.constant.basis</a></code>, 
<code><a href="create.exponential.basis.html">create.exponential.basis</a></code>, 
<code><a href="create.fourier.basis.html">create.fourier.basis</a></code>, 
<code><a href="create.monomial.basis.html">create.monomial.basis</a></code>, 
<code><a href="create.polygonal.basis.html">create.polygonal.basis</a></code>, 
<code><a href="create.polynomial.basis.html">create.polynomial.basis</a></code>, 
<code><a href="create.power.basis.html">create.power.basis</a></code>
<code><a onclick="findlink('stats', 'splineDesign.html')" style="text-decoration: underline; color: blue; cursor: hand">splineDesign</a></code>
<code><a onclick="findlink('stats', 'spline.des.html')" style="text-decoration: underline; color: blue; cursor: hand">spline.des</a></code>
</p>


<h3>Examples</h3>

<pre>
##
## The simplest basis currently available with this function:
##
bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=2:3)
plot(bspl1.1)
# 1 basis function, order 1 = degree 0 = step function:  
# constant 1 between 2 and 3.  

bspl1.2 &lt;- create.bspline.basis(norder=1, breaks=c(0,.5, 1))
plot(bspl1.2)
# 2 bases, order 1 = degree 0 = step functions:  
# (1) constant 1 between 0 and 0.5 and 0 otherwise
# (2) constant 1 between 0.5 and 1 and 0 otherwise.

bspl2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))
plot(bspl2.3)
# 3 bases:  order 2 = degree 1 = linear 
# (1) line from (0,1) down to (0.5, 0), 0 after
# (2) line from (0,0) up to (0.5, 1), then down to (1,0)
# (3) 0 to (0.5, 0) then up to (1,1).

bspl3.4 &lt;- create.bspline.basis(norder=3, breaks=c(0,.5, 1))
plot(bspl3.4)
# 4 bases:  order 3 = degree 2 = parabolas.  
# (1) (x-.5)^2 from 0 to .5, 0 after
# (2) 2*(x-1)^2 from .5 to 1, and a parabola
#     from (0,0 to (.5, .5) to match
# (3 &amp; 4) = complements to (2 &amp; 1).  

# Default B-spline basis
bSpl4.23 &lt;- create.bspline.basis()
# Cubic bspline (norder=4) with nbasis=23,
# so nbreaks = nbasis-norder+2 = 21, 
# 2 of which are rangeval, leaving 19 Interior knots.

bSpl4. &lt;- create.bspline.basis(c(-1,1))
# Same as bSpl4.23 but over (-1,1) rather than (0,1).

# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis &lt;- create.bspline.basis(c(0,1), 23)
all.equal(bSpl4.23, lipbasis)
# TRUE 
# plot the basis functions
plot(lipbasis)

bSpl.growth &lt;- create.bspline.basis(growth$age)
# cubic spline (order 4) 

bSpl.growth6 &lt;- create.bspline.basis(growth$age,norder=6)
# quintic spline (order 6) 
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>fda</em> version 2.0.0 <a href="00Index.html">Index]</a></div>

</body></html>
