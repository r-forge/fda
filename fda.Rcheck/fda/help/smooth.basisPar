smooth.basisPar             package:fda             R Documentation

_S_m_o_o_t_h _D_a_t_a _U_s_i_n_g _a _D_i_r_e_c_t_l_y _S_p_e_c_i_f_i_e_d _R_o_u_g_h_n_e_s_s _P_e_n_a_l_t_y

_D_e_s_c_r_i_p_t_i_o_n:

     Smooth (argvals, y) data with roughness penalty defined by the
     remaining arguments.

_U_s_a_g_e:

     smooth.basisPar(argvals, y, fdobj=NULL, Lfdobj=NULL,
           lambda=0, estimate=TRUE, penmat=NULL,
           wtvec=rep(1, length(argvals)), fdnames=NULL)

_A_r_g_u_m_e_n_t_s:

 argvals: a vector of argument values correspond to the observations in
          array 'y'. 

       y: an array containing values of curves at discrete sampling
          points or argument values. If the array is a matrix, the rows
          must correspond to argument values and columns to
          replications, and it will be assumed that there is only one
          variable per observation.  If 'y' is a three-dimensional
          array, the first dimension corresponds to argument values,
          the second to replications, and the third to variables within
          replications.  If 'y' is a vector, only one replicate and
          variable are assumed.   

   fdobj: One of the following:


        _f_d a functional data object (class 'fd')

        _b_a_s_i_s_f_d a functional basis object (class 'basisfd', which is
             converted to a functional data object with the identity
             matrix as the coefficient matrix. 

        _f_d_P_a_r a functional parameter object (class 'fdPar')

        _i_n_t_e_g_e_r an integer giving the order of a B-spline basis, which
             is further converted to a functional data object with the
             identity matrix as the coefficient matrix.  

        _m_a_t_r_i_x _o_r _a_r_r_a_y replaced by fd(fdobj)     

        _N_U_L_L Defaults to fdobj = create.bspline.basis(argvals).


  Lfdobj: either a nonnegative integer or a linear differential
          operator object.  If NULL and fdobj[['type']] == 'bspline',
          Lfdobj = int2Lfd(max(0, norder-2)), where norder = order of
          fdobj.    

  lambda: a nonnegative real number specifying the amount of smoothing
          to be applied to the estimated functional parameter. 

estimate: a logical value:  if 'TRUE', the functional parameter is
          estimated, otherwise, it is held fixed. 

  penmat: a roughness penalty matrix.  Including this can eliminate the
          need to compute this matrix over and over again in some types
          of calculations. 

   wtvec: a vector of the same length as 'argvals' containing weights
          for the values to be smoothed.  

 fdnames: a list of length 3 containing character vectors of names for
          the following: 


        _a_r_g_s name for each observation or point in time at which data
             are collected for each 'rep', unit or subject.

        _r_e_p_s name for each 'rep', unit or subject.

        _f_u_n name for each 'fun' or (response) variable measured
             repeatedly (per 'args') for each 'rep'.


_D_e_t_a_i_l_s:

     1.  if(is.null(fdobj))fdobj <- create.bspline.basis(argvals). 
     Else if(is.integer(fdobj)) fdobj <- create.bspline.basis(argvals,
     norder = fdobj) 

     2.  fdPar

     3.  smooth.basis

_V_a_l_u_e:

     The output of a call to 'smooth.basis', which is a named list of
     length 6 and class 'fdSmooth' with the following components:  

      fd: a functional data object that smooths the data. 

      df: a degrees of freedom measure of the smooth 

     gcv: the value of the generalized cross-validation or GCV
          criterion.  If there are multiple curves, this is a vector of
          values, one per curve.  If the smooth is multivariate, the
          result is a matrix of gcv values, with columns corresponding
          to variables.   

     SSE: the error sums of squares.  SSE is a vector or a matrix of
          the same size as 'gcv'.  

  penmat: the penalty matrix. 

  y2cMap: the matrix mapping the data to the coefficients. 

_R_e_f_e_r_e_n_c_e_s:

     Ramsay, James O., and Silverman, Bernard W. (2005), _Functional 
     Data Analysis, 2nd ed._, Springer, New York. 

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York.

_S_e_e _A_l_s_o:

     'Data2fd',  'df2lambda',  'fdPar',  'lambda2df',  'lambda2gcv', 
     'plot.fd',  'project.basis',  'smooth.basis',  'smooth.fd', 
     'smooth.monotone',  'smooth.pos'

_E_x_a_m_p_l_e_s:

     ##
     ## simplest call
     ##
     girlGrowthSm <- with(growth, smooth.basisPar(argvals=age, y=hgtf))
     plot(girlGrowthSm$fd, xlab="age", ylab="height (cm)",
              main="Girls in Berkeley Growth Study" )
     plot(deriv(girlGrowthSm$fd), xlab="age", ylab="growth rate (cm / year)",
              main="Girls in Berkeley Growth Study" )
     plot(deriv(girlGrowthSm$fd, 2), xlab="age",
             ylab="growth acceleration (cm / year^2)",
             main="Girls in Berkeley Growth Study" )
     #  Shows the effects of smoothing
     #  where the size of the third derivative is penalized.
     #  The null space contains quadratic functions.

     ##
     ## Another simple call
     ##
     lipSm <- smooth.basisPar(liptime, lip)
     plot(lipSm)
     # oversmoothing
     plot(smooth.basisPar(liptime, lip, lambda=1e-9))
     # more sensible 

     ##
     ## A third example 
     ##

     x <- seq(-1,1,0.02)
     y <- x + 3*exp(-6*x^2) + sin(1:101)/2
     # sin not rnorm to make it easier to compare
     # results across platforms 

     #  set up a saturated B-spline basis
     basisobj101 <- create.bspline.basis(x)
     fdParobj101 <- fdPar(basisobj101, 2, lambda=1)
     result101  <- smooth.basis(x, y, fdParobj101)

     resultP <- smooth.basisPar(argvals=x, y=y, fdobj=basisobj101, lambda=1)

     all.equal(result101, resultP)

     # TRUE 

     result4 <- smooth.basisPar(argvals=x, y=y, fdobj=4, lambda=1)

     all.equal(resultP, result4)

     # TRUE 

     result4. <- smooth.basisPar(argvals=x, y=y, lambda=1)

     all.equal(resultP, result4.)

     # TRUE

     with(result4, c(df, gcv)) #  display df and gcv measures

     result4.4 <- smooth.basisPar(argvals=x, y=y, lambda=1e-4)
     with(result4.4, c(df, gcv)) #  display df and gcv measures
     # less smoothing, more degrees of freedom, better fit 

     plot(result4.4)
     lines(result4, col='green')
     lines(result4$fd, col='green') # same as lines(result4, ...)

     result4.0 <- smooth.basisPar(x, y, basisobj101, lambda=0)

     result4.0a <- smooth.basisPar(x, y, lambda=0)

     all.equal(result4.0, result4.0a)


     with(result4.0, c(df, gcv)) #  display df and gcv measures
     # no smoothing, degrees of freedom = number of points 
     # but generalized cross validation = Inf
     # suggesting overfitting.  

     ##
     ## fdnames?
     ##
     girlGrow12 <- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
                   fdnames=c('age', 'girl', 'height')) ) 
     girlGrow12. <- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
         fdnames=list(age=age, girl=c('Carol', 'Sally'), value='height')) )

