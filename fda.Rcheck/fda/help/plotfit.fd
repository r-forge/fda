plotfit                 package:fda                 R Documentation

_P_l_o_t _a _F_u_n_c_t_i_o_n_a_l _D_a_t_a _O_b_j_e_c_t _W_i_t_h _D_a_t_a

_D_e_s_c_r_i_p_t_i_o_n:

     Plot either functional data observations 'x' with a fit 'fdobj' or
     residuals from the fit. 

     This function is useful for assessing how well a functional data
     object fits the actual discrete data.

     The default is to make one plot per functional observation with
     fit if residual is FALSE and superimposed lines if residual==TRUE.       

     With multiple plots, the system waits to confirm a desire to move
     to the next page unless ask==FALSE.

_U_s_a_g_e:

     plotfit.fd(y, argvals, fdobj, rng = NULL, index = NULL,
           nfine = 101, residual = FALSE, sortwrd = FALSE, titles=NULL,
           ylim=NULL, ask=TRUE, type=c("p", "l")[1+residual],
           xlab=NULL, ylab=NULL, sub=NULL, col=1:9, lty=1:9, lwd=1,
           cex.pch=1, ...)
     plotfit.fdSmooth(y, argvals, fdSm, rng = NULL, index = NULL,
           nfine = 101, residual = FALSE, sortwrd = FALSE, titles=NULL,
           ylim=NULL, ask=TRUE, type=c("p", "l")[1+residual],
           xlab=NULL, ylab=NULL, sub=NULL, col=1:9, lty=1:9, lwd=1,
           cex.pch=1, ...) 

_A_r_g_u_m_e_n_t_s:

       y: a vector, matrix or array containing the discrete
          observations used to estimate the functional data object.  

 argvals: a vector containing the argument values corresponding to the
          first dimension of 'y'.  

   fdobj: a functional data object estimated from the data. 

    fdSm: an object of class 'fdSmooth' 

     rng: a vector of length 2 specifying the limits for the horizontal
          axis. This must be a subset of
          fdobj[['basis']][['rangeval']], which is the default.  

   index: a set of indices of functions if only a subset of the
          observations are to be plotted.  Subsetting can also be
          achieved by subsetting 'y';  see 'details', below.   

   nfine: the number of argument values used to define the plot of the
          functional data object.  This may need to be increased if the
          functions have a great deal of fine detail.  

residual: a logical variable:  if 'TRUE', the residuals are plotted
          rather than the data and functional data object. 

 sortwrd: a logical variable:  if 'TRUE', the observations (i.e.,
          second dimension of 'y') are sorted for plotting by the size
          of the sum of squared residuals.  

  titles: a vector containing strings that are titles for each
          observation. 

    ylim: a numeric vector of length 2 giving the y axis limits;  see
          'par'.   

     ask: If TRUE and if 'y' has more levels than the max length of
          col, lty, lwd and cex.pch, the user must confirm page change
          before the next plot will be created. 

    type: type of plot desired, as described with 'plot'.  If residual
          == FALSE, 'type' controls the representation for 'x', which
          will typically be 'p' to plot points but not lines;  'fdobj'
          will always plot as a line.  If residual == TRUE, the default
          type == "l";  an alternative is "b" for both.   

    xlab: x axis label. 

    ylab: Character vector of y axis labels.  If(residual), ylab
          defaults to 'Residuals', else to varnames derived from
          names(fdnames[[3]] or fdnames[[3]] or dimnames(y)[[3]].  

     sub: subtitle under the x axis label.  Defaults to the RMS
          residual from the smooth.   

col, lty, lwd, cex.pch: Numeric or character vectors specifying the
          color (col), line type (lty), line width (lwd) and size of
          plotted character symbols (cex.pch) of the data
          representation on the plot. 

          If ask==TRUE, the length of the longest of these determines
          the number of levels of the array 'x' in each plot before
          asking the user to acknowledge a desire to change to the next
          page.  Each of these is replicated to that length, so col[i]
          is used for x[,i] (if x is 2 dimensional), with line type and
          width controlled by lty[i] and lwd[i], respectively.  

          If ask==FALSE, these are all replicated to length = the
          number of plots to be superimposed.

          For more information on alternative values for these
          paramters, see 'col', 'lty', 'lwd', or 'cex' with 'par'.     

    ... : additional arguments such as axis labels that may be used
          with other 'plot' functions.  

_D_e_t_a_i_l_s:

     'plotfit' plots discrete data along with a functional data object
     for fitting the data.  It is designed to be used after something
     like 'data2fd', 'smooth.fd', 'smooth.basis' or 'smoothe.basisPar'
     to check the fit of the data offered by the 'fd' object.

     'plotfit.fdSmooth' calls 'plotfit' for its 'fd' component.

     The plot can be restricted to a subset of observations (i.e.,
     second dimension of 'y') or variables (i.e., third dimension of
     'y') by providing 'y' with the dimnames for its second and third
     dimensions matching a subset of the dimnames of fdobj[['coef']]
     (for 'plotfit.fd' or fdSm[['fdobj']][['coef']] for
     'plotfit.fdSmooth').  If only one observation or variable is to be
     plotted, 'y' must include 'drop = TRUE', as, e.g., y[, 2, 3,
     drop=TRUE].  If 'y' or fdobj[['coef']] does not have dimnames on
     its second or third dimension, subsetting is acheived by taking
     the first few colums so the second or third dimensions match. 
     This is acheived using checkDims3(y, fdobj[['coef']], defaultNames
     = fdobj[['fdnames']]]).

_V_a_l_u_e:

     A matrix of mean square deviations from predicted is returned
     invisibly.  If fdobj[["coefs"]] is a 3-dimensional array, this is
     a matrix of dimensions equal to the last two dimensions of
     fdobj[["coefs"]].  This will typically be the case when x is also
     a 3-dimensional array with the last two dimensions matching those
     of fdobj[["coefs"]].  The second dimension is typically
     replications and the third different variables.

     If x and fobj[["coefs"]] are vectors or 2-dimensional arrays, they
     are padded to three dimensions, and then MSE is computed as a
     matrix with the second dimension = 1;  if x and fobj[["coefs"]]
     are vectors, the first dimension of the returned matrix will also
     be 1.

_S_i_d_e _E_f_f_e_c_t_s:

     a plot of the the data 'x' with the function or the deviations
     between observed and predicted, depending on whether residual is
     FALSE or TRUE.

_S_e_e _A_l_s_o:

     'plot',  'plot.fd',  'lines.fd' 'plot.fdSmooth',  'lines.fdSmooth'
     'par' 'data2fd' 'smooth.fd' 'smooth.basis' 'smooth.basisPar'
     'checkDims3'

_E_x_a_m_p_l_e_s:

     daybasis65 <- create.fourier.basis(c(0, 365), 65)

     daytempfd <- with(CanadianWeather, data2fd(
            dailyAv[,,"Temperature.C"], day.5, 
            daybasis65, argnames=list("Day", "Station", "Deg C")) )
      
     with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C"],
          argvals= day.5, daytempfd, index=1, titles=place, axes=FALSE) )
     # Default ylab = daytempfd[['fdnames']] 

     with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C", drop=FALSE],
          argvals= day.5, daytempfd, index=1, titles=place, axes=FALSE) )
     # Better:  ylab = dimnames(y)[[3]]

     # Label the horizontal axis with the month names
     axis(1, monthBegin.5, labels=FALSE)
     axis(1, monthEnd.5, labels=FALSE)
     axis(1, monthMid, monthLetters, tick=FALSE)
     axis(2)

     ## Not run: 
     # The following pauses to request page changes.
     # (Without 'dontrun', the package build process
     # might encounter problems with the par(ask=TRUE)
     # feature.)
     with(CanadianWeather, plotfit.fd(
               dailyAv[,, "Temperature.C"], day.5,
               daytempfd, ask=TRUE) )
     ## End(Not run)

     # If you want only the fitted functions, use plot(daytempfd)

     # To plot only a single fit vs. observations, use index
     # to request which one you want.  

     op <- par(mfrow=c(2,1), xpd=NA, bty="n")
     # xpd=NA:  clip lines to the device region,
     #       not the plot or figure region
     # bty="n":  Do not draw boxes around the plots.  
     ylim <- range(CanadianWeather$dailyAv[,,"Temperature.C"])
     # Force the two plots to have the same scale 
     with(CanadianWeather, plotfit.fd(dailyAv[,,"Temperature.C"], day.5, 
               daytempfd, index=2, titles=place, ylim=ylim, axes=FALSE) )
     axis(1, monthBegin.5, labels=FALSE)
     axis(1, monthEnd.5, labels=FALSE)
     axis(1, monthMid, monthLetters, tick=FALSE)
     axis(2)

     with(CanadianWeather, plotfit.fd(dailyAv[,,"Temperature.C"], day.5, 
               daytempfd, index=35, titles=place, ylim=ylim) )
     axis(1, monthBegin.5, labels=FALSE)
     axis(1, monthEnd.5, labels=FALSE)
     axis(1, monthMid, monthLetters, tick=FALSE)
     axis(2)
     par(op)

     # plot residuals
     with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C"], 
               day.5, daytempfd, residual=TRUE) )
     # Can't read this, so try with 2 lines per page with ask=TRUE, 
     # and limiting length(col), length(lty), etc. <=2
     ## Not run: 
     with(CanadianWeather, plotfit.fd(
               dailyAv[,,"Temperature.C"], day.5, 
               daytempfd, residual=TRUE, col=1:2, lty=1, ask=TRUE) )
     ## End(Not run)

