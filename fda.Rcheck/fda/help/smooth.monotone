smooth.monotone             package:fda             R Documentation

_M_o_n_o_t_o_n_e _S_m_o_o_t_h_i_n_g _o_f _D_a_t_a

_D_e_s_c_r_i_p_t_i_o_n:

     When the discrete data that are observed reflect a smooth strictly
     increasing or strictly decreasing function, it is often desirable
     to smooth the data with a strictly monotone function, even though
     the data themselves may not be monotone due to observational
     error.  An example is when data are collected on the size of a
     growing organism over time.  This function computes such a
     smoothing function, but, unlike other smoothing functions, for
     only for one curve at a time. The smoothing function minimizes a
     weighted error sum of squares criterion.  This minimization
     requires iteration, and therefore is more computationally
     intensive than normal smoothing.

     The monotone smooth is beta[1]+beta[2]*integral(exp(Wfdobj)),
     where Wfdobj is a functional data object.  Since exp(Wfdobj)>0,
     its integral is monotonically increasing.

_U_s_a_g_e:

     smooth.monotone(argvals, y, WfdParobj, wtvec=rep(1,n),
                     zmat=NULL, conv=.0001, iterlim=50,
                     active=rep(TRUE,nbasis), dbglev=1)

_A_r_g_u_m_e_n_t_s:

 argvals: Argument value array of length N, where N is the number of
          observed curve values for each curve.  It is assumed that
          that these argument values are common to all observed curves.
           If this is not the case, you will need to run this function
          inside one or more loops, smoothing each curve separately. 

       y: a vector of data values.  This function can only smooth one
          set of data at a time.

          Function value array (the values to be fit).  If the
          functional data are univariate, this array will be an N by
          NCURVE matrix, where N is the number of observed curve values
          for each curve and NCURVE is the number of curves observed. 
          If the functional data are muliivariate, this array will be
          an N by NCURVE by NVAR matrix, where NVAR the number of
          functions observed per case.  For example, for the gait data,
          NVAR = 2, since we observe knee and hip angles. 

WfdParobj: A functional parameter or fdPar object.  This object
          contains the specifications for the functional data object to
          be estimated by smoothing the data.  See comment lines in
          function fdPar for details.  The functional data object WFD
          in WFDPAROBJ is used to initialize the optimization process. 
          Its coefficient array contains the starting values for the
          iterative minimization of mean squared error. 

   wtvec: a vector of weights to be used in the smoothing. 

    zmat: a design matrix or a matrix of covariate values that also
          define the smooth of the data. 

    conv: a convergence criterion. 

 iterlim: the maximum number of iterations allowed in the minimization
          of error sum of squares. 

  active: a logical vector specifying which coefficients defining
          $W(t)$ are estimated.  Normally, the first coefficient is
          fixed. 

  dbglev: either 0, 1, or 2.  This controls the amount information
          printed out on each iteration, with 0 implying no output, 1
          intermediate output level, and 2 full output.  If either
          level 1 or 2 is specified, it can be helpful to turn off the
          output buffering feature of S-PLUS. 

_D_e_t_a_i_l_s:

     The smoothing function  $f(argvals)$ is determined by three
     objects that need to be estimated from the data:


        *  $W(argvals)$, a functional data object that is first
           exponentiated and then the result integrated.  This is the
           heart of the monotone smooth.  The closer $W(argvals)$ is to
           zero, the closer the monotone smooth becomes a straight
           line.  The closer $W(argvals)$ becomes a constant, the more
           the monotone smoother becomes an exponential function.  It
           is assumed that $W(0) = 0.$

        *  $b0$, an intercept term that determines the value of the
           smoothing function at $argvals = 0$.

        *  $b1$, a regression coefficient that determines the slope of
           the smoothing function at $argvals = 0$.

     In addition, it is possible to have the intercept $b0$ depend in
     turn on the values of one or more covariates through the design
     matrix 'Zmat' as follows: $b0 = Z c$. In this case, the single
     intercept coefficient is replaced by the regression coefficients
     in vector $c$ multipying the design matrix.

_V_a_l_u_e:

     a named list of length 5 containing:

  Wfdobj: a functional data object defining function $W(argvals)$ that
          optimizes the fit to the data of the monotone function that
          it defines. 

    beta: The regression coefficients $b_0$ and $b_1$ for each smoothed
          curve.

          If the curves are univariate and ... ZMAT is NULL,       BETA
          is 2   by NCURVE. ... ZMAT has P columns, BETA is P+1 by
          NCURVE.

          If the curves are multivariate and ... ZMAT is NULL,      
          BETA is 2   by NCURVE by NVAR. ... ZMAT has P columns, BETA
          is P+1 by NCURVE by NVAR. 

  yhatfd: A functional data object for the monotone curves that smooth
          the data 

   Flist: a named list containing three results for the final converged
          solution:  (1) *f*: the optimal function value being
          minimized, (2) *grad*: the gradient vector at the optimal
          solution, and (3) *norm*: the norm of the gradient vector at
          the optimal solution. 

  y2cMap: For each estimated curve (and variable if functions are
          multivariate, this is an N by NBASIS matrix containing a
          linear mappping from data to coefficients that can be used
          for computing point-wise confidence intervals.  If NCURVE =
          NVAR = 1, a matrix is returned.  Otherwise an NCURVE by NVAR
          list is returned, with each slot containing this mapping. 

 argvals: input 'argvals', possibly modified / clarified by 'argcheck'. 

       y: input argument 'y', possibly modified / clarified by
          'ycheck'. 

_R_e_f_e_r_e_n_c_e_s:

     Ramsay, James O., and Silverman, Bernard W. (2005), _Functional
     Data Analysis, 2nd ed._, Springer, New York.

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York.

_S_e_e _A_l_s_o:

     'smooth.basis', 'smooth.pos', 'smooth.morph'

_E_x_a_m_p_l_e_s:

     #  Estimate the acceleration functions for growth curves
     #  See the analyses of the growth data.
     #  Set up the ages of height measurements for Berkeley data
     age <- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
     #  Range of observations
     rng <- c(1,18)
     #  First set up a basis for monotone smooth
     #  We use b-spline basis functions of order 6
     #  Knots are positioned at the ages of observation.
     norder <- 6
     nage   <- 31
     nbasis <- nage + norder - 2
     wbasis <- create.bspline.basis(rng, nbasis, norder, age)
     #  starting values for coefficient
     cvec0 <- matrix(0,nbasis,1)
     Wfd0  <- fd(cvec0, wbasis)
     #  set up functional parameter object
     Lfdobj    <- 3          #  penalize curvature of acceleration
     lambda    <- 10^(-0.5)  #  smoothing parameter
     growfdPar <- fdPar(Wfd0, Lfdobj, lambda)
     #  Set up wgt vector
     wgt   <- rep(1,nage)
     #  Smooth the data for the first girl
     hgt1 = growth$hgtf[,1]
     result <- smooth.monotone(age, hgt1, growfdPar, wgt)
     #  Extract the functional data object and regression
     #  coefficients
     Wfd  <- result$Wfdobj
     beta <- result$beta
     #  Evaluate the fitted height curve over a fine mesh
     agefine <- seq(1,18,len=101)
     hgtfine <- beta[1] + beta[2]*eval.monfd(agefine, Wfd)
     #  Plot the data and the curve
     plot(age, hgt1, type="p")
     lines(agefine, hgtfine)
     #  Evaluate the acceleration curve
     accfine <- beta[2]*eval.monfd(agefine, Wfd, 2)
     #  Plot the acceleration curve
     plot(agefine, accfine, type="l")
     lines(c(1,18),c(0,0),lty=4)

