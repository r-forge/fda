create.basis               package:fda               R Documentation

_C_r_e_a_t_e _B_a_s_i_s _S_e_t _f_o_r _F_u_n_c_t_i_o_n_a_l _D_a_t_a _A_n_a_l_y_s_i_s

_D_e_s_c_r_i_p_t_i_o_n:

     Functional data analysis proceeds by selecting a finite basis set
     and fitting data to it.  The current 'fda' package supports
     fitting via least squares penalized with lambda times the integral
     over the (finite) support of the basis set of the squared
     deviations from a linear differential operator.

_D_e_t_a_i_l_s:

     The most commonly used basis in 'fda' is probably B-splines.  For
     periodic phenomena, Fourier bases are quite useful.  A constant
     basis is provided to facilitation arithmetic with functional data
     objects. To restrict attention to solutions of certain
     differential equations, it may be useful to use a corresponding
     basis set such as exponential, monomial, polynomial, or power
     basis sets.

     Monomial and polynomial bases are similar.  As noted in the table
     below, 'create.monomial.basis' has an argument 'exponents' absent
     from 'create.polynomial.basis', which has an argument 'ctr' absent
     from 'create.monomial.basis'.

     Power bases support the use of negative and fractional powers,
     while monomial bases are restricted only to nonnegative integer
     exponents.

     The polygonal basis is essentialy a B-spline of order 2, degree 1.

     The following summarizes arguments used by some or all of the
     current 'create.basis' functions:


   _r_a_n_g_e_v_a_l_s a vector of length 2 giving the lower and upper limits of
        the range of permissible values for the function argument.

        For 'bspline' bases, this can be inferred from range(breaks). 
        For 'polygonal' bases, this can be inferred from
        range(argvals).  In all other cases, this defaults to 0:1.

   _n_b_a_s_i_s an integer giving the number of basis functions.

        This is not used for two of the 'create.basis' functions: For
        'constant' this is 1, so there is no need to specify it. For
        'polygonal' bases, it is length(argvals), and again there is no
        need to specify it.

        For 'bspline' bases, if 'nbasis' is not specified, it defaults
        to (length(breaks) + norder - 2) if 'breaks' is provided. 
        Otherwise, 'nbasis' defaults to 20 for 'bspline' bases.

        For 'exponential' bases, if 'nbasis' is not specified, it
        defaults to length(ratevec) if 'ratevec' is provided.
        Otherwise, in 'fda_2.0.2', 'ratevec' defaults to 1, which makes
        'nbasis' = 1;  in 'fda_2.0.4', 'ratevec' will default to 0:1,
        so 'nbasis' will then default to 2.

        For 'monomial' and 'power' bases, if 'nbasis' is not specified,
        it defaults to length(exponents) if 'exponents' is provided. 
        Otherwise, 'nbasis' defaults to 2 for 'monomial' and 'power'
        bases.  (Temporary exception:  In 'fda_2.0.2', the default
        'nbasis' for 'power' bases is 1.  This will be increased to 2
        in 'fda_2.0.4'.)

        For 'polynomial' bases, 'nbasis' defaults to 2.

        In addition to 'rangevals' and 'nbasis', all but 'constant'
        bases have one or two parameters unique to that basis type or
        shared with one other:


      _b_s_p_l_i_n_e Argument 'norder' = the order of the spline, which is one
           more than the degree of the polynomials used.  This defaults
           to 4, which gives cubic splines.

           Argument 'breaks' = the locations of the break or join
           points;  also called 'knots'.  This defaults to
           seq(rangevals[1], rangevals[2], nbasis-norder+2).

      _p_o_l_y_g_o_n_a_l Argument 'argvals' = the locations of the break or join
           points;  also called 'knots'.  This defaults to
           seq(rangevals[1], rangevals[2], nbasis).

      _f_o_u_r_i_e_r Argument 'period' defaults to diff(rangevals).

      _e_x_p_o_n_e_n_t_i_a_l Argument 'ratevec'.  In 'fda_2.0.2', this defaulted
           to 1.  In 'fda_2.0.3', it will default to 0:1.

      _m_o_n_o_m_i_a_l, _p_o_w_e_r Argument 'exponents'.  Default = 0:(nbasis-1). 
           For 'monomial' bases, 'exponents' must be distinct
           nonnegative integers.  For 'power' bases, they must be
           distinct real numbers.

      _p_o_l_y_n_o_m_i_a_l Argument 'ctr' must be a single number used to shift
           the argument prior to computing its powers.  Default =
           mean(rangeval).


        Beginning with 'fda_2.0.3', the last 5 arguments for all the
        'create.basis' functions will be as follows;  some but not all
        are available in the previous versions of 'fda':


      _d_r_o_p_i_n_d a vector of integers specifiying the basis functions to
           be dropped, if any.

      _q_u_a_d_v_a_l_s a matrix with two columns and a number of rows equal to
           the number of quadrature points for numerical evaluation of
           the penalty integral.  The first column of 'quadvals'
           contains the quadrature points, and the second column the
           quadrature weights.  A minimum of 5 values are required for
           each inter-knot interval, and that is often enough.  For
           Simpson's rule, these points are equally spaced, and the
           weights are proportional to 1, 4, 2, 4, ..., 2, 4, 1.

      _v_a_l_u_e_s a list of matrices with one row for each row of 'quadvals'
           and one column for each basis function.  The elements of the
           list correspond to the basis functions and their derivatives
           evaluated at the quadrature points contained in the first
           column of 'quadvals'.

      _b_a_s_i_s_v_a_l_u_e_s A list of lists, allocated by code such as
           vector("list",1). This field is designed to avoid evaluation
           of a basis system repeatedly at a set of argument values. 
           Each list within the vector corresponds to a specific set of
           argument values, and must have at least two components,
           which may be tagged as you wish.  `The first component in an
           element of the list vector contains the argument values. 
           The second component in an element of the list vector
           contains a matrix of values of the basis functions evaluated
           at the arguments in the first component.  The third and
           subsequent components, if present, contain matrices of
           values their derivatives up to a maximum derivative order. 
           Whenever function getbasismatrix is called, it checks the
           first list in each row to see, first, if the number of
           argument values corresponds to the size of the first
           dimension, and if this test succeeds, checks that all of the
           argument values match.  This takes time, of course, but is
           much faster than re-evaluation of the basis system.  Even
           this time can be avoided by direct retrieval of the desired
           array.  For example, you might set up a vector of argument
           values called "evalargs" along with a matrix of basis
           function values for these argument values called "basismat".
            You might want too use tags like "args" and "values",
           respectively for these.  You would then assign them to
           'basisvalues' with code such as the following:

           basisobj$basisvalues <- vector("list",1)

           basisobj$basisvalues[[1]] <- list(args=evalargs,
           values=basismat)

      _n_a_m_e_s either a character vector of the same length as the number
           of basis functions or a simple stem used to construct such a
           vector.

           For 'bspline' bases, this defaults to paste('bspl', norder,
           '.', 1:nbreaks, sep='').

           For other bases, there are crudely similar defaults.



_A_u_t_h_o_r(_s):

     J. O. Ramsay and Spencer Graves

_R_e_f_e_r_e_n_c_e_s:

     Ramsay, James O., and Silverman, Bernard W. (2005), _Functional
     Data Analysis, 2nd ed._, Springer, New York.

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York.

_S_e_e _A_l_s_o:

     'create.bspline.basis' 'create.constant.basis'
     'create.exponential.basis' 'create.fourier.basis'
     'create.monomial.basis' 'create.polygonal.basis'
     'create.polynomial.basis' 'create.power.basis'

