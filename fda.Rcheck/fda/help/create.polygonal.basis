create.polygonal.basis          package:fda          R Documentation

_C_r_e_a_t_e _a _P_o_l_y_g_o_n_a_l _B_a_s_i_s

_D_e_s_c_r_i_p_t_i_o_n:

     A basis is set up for constructing polygonal lines, consisting of
     straight line segments that join together.

_U_s_a_g_e:

     create.polygonal.basis(rangeval=NULL, argvals=NULL, dropind=NULL,
             quadvals=NULL, values=NULL, basisvalues=NULL, names='polygon')

_A_r_g_u_m_e_n_t_s:

rangeval: a numeric vector of length 2 defining the interval over which
          the functional data object can be evaluated;  default value
          is 'if(is.null(argvals)) 0:1 else range(argvals)'.

          If 'length(rangeval) == 1' and 'rangeval <= 0', this is an
          error.  Otherwise, if 'length(rangeval) == 1', 'rangeval' is
          replaced by 'c(0,rangeval)'.

          If length(rangeval)>2 and 'argvals' is not provided, this
          extra long 'rangeval' argument is assigned to 'argvals', and
          then 'rangeval = range(argvale)'. 

 argvals: a strictly increasing vector of argument values at which line
          segments join to form a polygonal line. 

 dropind: a vector of integers specifiying the basis functions to be
          dropped, if any.  For example, if it is required that a
          function be zero at the left boundary, this is achieved by
          dropping the first basis function, the only one that is
          nonzero at that point. 

quadvals: a matrix with two columns and a number of rows equal to the
          number of quadrature points for numerical evaluation of the
          penalty integral.  The first column of 'quadvals' contains
          the quadrature points, and the second column the quadrature
          weights.  A minimum of 5 values are required for each
          inter-knot interval, and that is often enough.  For Simpson's
          rule, these points are equally spaced, and the weights are
          proportional to These are proportional to 1, 4, 2, 4, ..., 2,
          4, 1. 

  values: a list containing the basis functions and their derivatives
          evaluated at the quadrature points contained in the first
          column of ' quadvals '. 

basisvalues: A list of lists, allocated by code such as
          vector("list",1).  This is designed to avoid evaluation of a
          basis system repeatedly at a set of argument values.  Each
          sublist corresponds to a specific set of argument values, and
          must have at least two components, which may be named as you
          wish.  The first component of a sublist contains the argument
          values.  The second component contains a matrix of values of
          the basis functions evaluated at the arguments in the first
          component.  The third and subsequent components, if present,
          contain matrices of values their derivatives up to a maximum
          derivative order.  Whenever function 'getbasismatrix' is
          called, it checks the first list in each row to see, first,
          if the number of argument values corresponds to the size of
          the first dimension, and if this test succeeds, checks that
          all of the argument values match.  This takes time, of
          course, but is much faster than re-evaluation of the basis
          system.  Even this time can be avoided by direct retrieval of
          the desired array. For example, you might set up a vector of
          argument values called "evalargs" along with a matrix of
          basis function values for these argument values called
          "basismat".  You might want too use tags like "args" and
          "values", respectively for these.  You would then assign them
          to 'basisvalues' with code such as the following:

          basisobj$basisvalues <- vector("list",1)

          basisobj$basisvalues[[1]] <- list(args=evalargs,
          values=basismat) 

   names: either a character vector of the same length as the number of
          basis functions or a single character string to which
          '1:nbasis' are appended as 'paste(names, 1:nbasis, sep='''. 
          For example, if 'nbasis = 4', this defaults to 'c('polygon1',
          'polygon2', 'polygon3', 'polygon4')'. 

_D_e_t_a_i_l_s:

     The actual basis functions consist of triangles, each with its
     apex over an argument value. Note that in effect the polygonal
     basis is identical to a B-spline basis of order 2 and a knot or
     break value at each argument value.  The range of the polygonal
     basis is set to the interval defined by the smallest and largest
     argument values.

_V_a_l_u_e:

     a basis object with the type 'polyg'.

_S_e_e _A_l_s_o:

     'basisfd', 'create.bspline.basis', 'create.basis',
     'create.constant.basis', 'create.exponential.basis',
     'create.fourier.basis', 'create.monomial.basis',
     'create.polynomial.basis', 'create.power.basis'

_E_x_a_m_p_l_e_s:

     #  Create a polygonal basis over the interval [0,1]
     #  with break points at 0, 0.1, ..., 0.95, 1
     (basisobj <- create.polygonal.basis(seq(0,1,0.1)))
     #  plot the basis
     plot(basisobj)

