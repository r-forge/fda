CSTR                   package:fda                   R Documentation

_C_o_n_t_i_n_u_o_u_s_l_y _S_t_i_r_r_e_d _T_e_m_p_e_r_a_t_u_r_e _R_e_a_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     Functions for solving the Continuously Stirred Temperature Reactor
     (CSTR) Ordinary Differential Equations (ODEs).  A solution for
     observations where metrology error is assumed to be negligible can
     be  obtained via lsoda(y, Time, CSTR2, parms);  CSTR2 calls
     CSTR2in.  When metrology error can not be ignored, use CSTRfn
     (which calls CSTRfitLS).  To estimate parameters in the CSTR
     differential equation system (kref, EoverR, a, and / or b), pass
     either CSTRres or CSTRres0 to nls.  If nls fails to converge,
     first use optim or nlminb with CSTRsse, then pass the estimates to
     nls.

_U_s_a_g_e:

     CSTR2in(Time, condition =
        c('all.cool.step', 'all.hot.step', 'all.hot.ramp', 'all.cool.ramp',
          'Tc.hot.exponential', 'Tc.cool.exponential', 'Tc.hot.ramp',
          'Tc.cool.ramp', 'Tc.hot.step', 'Tc.cool.step'),
        tau=1)
     CSTR2(Time, y, parms)  

     CSTRfitLS(coef, datstruct, fitstruct, lambda, gradwrd=FALSE)
     CSTRfn(parvec, datstruct, fitstruct, CSTRbasis, lambda, gradwrd=TRUE)
     CSTRres(kref=NULL, EoverR=NULL, a=NULL, b=NULL,
             datstruct, fitstruct, CSTRbasis, lambda, gradwrd=FALSE)
     CSTRres0(kref=NULL, EoverR=NULL, a=NULL, b=NULL, gradwrd=FALSE)
     CSTRsse(par, datstruct, fitstruct, CSTRbasis, lambda)

_A_r_g_u_m_e_n_t_s:

    Time: The time(s) for which computation(s) are desired 

condition: a character string with the name of one of ten preprogrammed
          input scenarios.   

    tau : time for exponential decay of exp(-1) under condition =
          'Tc.hot.exponential' or 'Tc.cool.exponential';  ignored for
          other values of 'condition'.  

       y: Either a vector of length 2 or a matrix with 2 columns giving
          the observation(s) on Concentration and Temperature for which
          computation(s) are desired   

   parms: a list of CSTR model parameters passed via the lsoda 'parms'
          argument.  This list consists of the following 3 components:  


        _f_i_t_s_t_r_u_c_t a list with 12 components describing the structure
             for fitting. This is the same as the 'fitstruct' argument
             of 'CSTRfitLS' and 'CSTRfn' without the 'fit' component; 
             see below.


        _c_o_n_d_i_t_i_o_n a character string identifying the inputs to the
             simulation. Currently, any of the following are accepted: 
             'all.cool.step', 'all.hot.step', 'all.hot.ramp',
             'all.cool.ramp', 'Tc.hot.exponential',
             'Tc.cool.exponential', 'Tc.hot.ramp', 'Tc.cool.ramp',
             'Tc.hot.step', or 'Tc.cool.step'.  

        _T_l_i_m end time for the computations.


    coef: a matrix with one row for each basis function in fitstruct
          and columns c("Conc", "Temp") or a vector form of such a
          matrix.   

datstruct: a list describing the structure of the data.  CSTRfitLS uses
          the following components:


        _b_a_s_i_s_m_a_t, _D_b_a_s_i_s_m_a_t basis coefficent matrices with one row for
             each observation and one column for each basis vector. 
             These are typically produced by code something like the
             following:

             basismat <- eval.basis(Time, CSTRbasis)

             Dbasismat <- eval.basis(Time, CSTRbasis, 1) 

        _C_w_t, _T_w_t scalar variances of 'fd' functional data objects for
             Concentration and Temperature used to place the two series
             on comparable scales.   


        _y a matrix with 2 columns for the observed 'Conc' and 'Temp'.

        _q_u_a_d_b_a_s_i_s_m_a_t, _D_q_u_a_d_b_a_s_i_s_m_a_t basis coefficient matrices with one
             row for each quadrature point and one column for each
             basis vector.  These are typically produced by code
             something like the following:  

             quadbasismat <- eval.basis(quadpts, CSTRbasis) 

             Dquadbasismat <- eval.basis(quadpts, CSTRbasis, 1)


        _F_c, _F., _C_A_0, _T_0, _T_c input series for CSTRfitLS and CSTRfn as
             the output list produced by CSTR2in.


        _q_u_a_d_p_t_s Quadrature points created by 'quadset' and stored in
             CSTRbasis[["quadvals"]][, "quadpts"].   

        _q_u_a_d_w_t_s Quadrature weights created by 'quadset' and stored in
             CSTRbasis[["quadvals"]][, "quadpts"].  


fitstruct: a list with 14 components:  


        _V volume in cubic meters

        _C_p concentration in cal/(g.K) for computing betaTC and betaTT; 
             see details below. 

        _r_h_o density in grams per cubic meter 

        _d_e_l_H cal/kmol 

        _C_p_c concentration in cal/(g.K) used for computing alpha;  see
             details below. 

        _T_r_e_f reference temperature. 

        _k_r_e_f reference value 

        _E_o_v_e_r_R E/R in units of K/1e4 

        _a scale factor for Fco in alpha;  see details below.

        _b power of Fco in alpha;  see details below.

        _T_c_i_n Tc input temperature vector.

        _f_i_t logical vector of length 2 indicating whether Contentration
             or Temperature or both are considered to be observed and
             used for parameter estimation. 

        _c_o_e_f_0 data.frame(Conc = Cfdsmth[["coef"]], Temp =
             Tfdsmth[["coef"]]), where Cfdsmth and Tfdsmth are the
             objects returned by smooth.basis when applied to the
             observations on Conc and Temp, respectively.  

        _e_s_t_i_m_a_t_e logical vector of length 4 indicating which of kref,
             EoverR, a and b are taken from 'parvec';  all others are
             taken from 'fitstruct'.  


  lambda: a 2-vector of rate parameters 'lambdaC' and 'lambdaT'.   

 gradwrd: a logical scalar TRUE if the gradient is to be returned as
          well as the residuals matrix.       

parvec, par: initial values for the parameters specified by fitstruct[[
          "estimate"]] to be estimated.  

CSTRbasis: Quadrature basis returned by 'quadset'.   

kref, EoverR, a, b: the kref, EoverR, a, and b coefficients of the CSTR
          model as individual arguments of CSTRres to support using
          'nls' with the CSTR model.  Those actually provided by name
          will be estimated;  the others will be taken from
          '.fitstruct';  see details.    

_D_e_t_a_i_l_s:

     Ramsay et al. (2007) considers the following differential equation
      system for a continuously stirred temperature reactor (CSTR):

     dC/dt = (-betaCC(T, F.in)*C + F.in*C.in)

     dT/dt = (-betaTT(Fcvec, F.in)*T + betaTC(T, F.in)*C +
     alpha(Fcvec)*T.co)

     where

     betaCC(T, F.in) = kref*exp(-1e4*EoverR*(1/T - 1/Tref)) + F.in

     betaTT(Fcvec, F.in) = alpha(Fcvec) + F.in

     betaTC(T, F.in) = (-delH/(rho*Cp))*betaCC(T, F.in)


      alpha(Fcvec) = (a*Fcvec^(b+1) / (K1*(Fcvec + K2*Fcvec^b)))


     K1 = V*rho*Cp

     K2 = 1/(2*rhoc*Cpc)  

     The four functions CSTR2in, CSTR2, CSTRfitLS, and CSTRfn compute
     coefficients of basis vectors for two different solutions to this
     set of differential equations.  Functions CSTR2in and CSTR2 work
     with 'lsoda' to provide a solution to this system of equations. 
     Functions  CSTSRitLS and CSTRfn are used to estimate parameters to
     fit this differential equation system to noisy data.  These
     solutions are conditioned on specified values for kref, EoverR, a,
     and b.  The other two functions CSTRres and CSTRres0 support
     estimation of these parameters using 'nls'.    

     CSTR2in translates a character string 'condition' into a
     data.frame containing system inputs for which the reaction of the
     system is desired.  CSTR2 calls CSTR2in and then computes the
     corresponding predicted first derivatives of CSTR system outputs
     according to the right hand side of the system equations.  CSTR2
     can be called by 'lsoda' in the 'odesolve' package to actually
     solve the system of equations.  To solve the CSTR equations for
     another set of inputs, the easiest modification might be to change
     CSTR2in to return the desired inputs.  Another alternative would
     be to add an argument 'input.data.frame' that would be used in
     place of CSTR2in when present.

     CSTRfitLS computes standardized residuals for systems outputs
     Conc,  Temp or both as specified by fitstruct[["fit"]], a logical
     vector of  length 2.  The standardization is
     sqrt(datstruct[["Cwt"]]) and / or sqrt(datstruct[["Twt"]]) for
     Conc and Temp, respectively.  CSTRfitLS also returns standardized
     deviations from the predicted first derivatives for Conc and Temp.

     CSTRfn uses a Gauss-Newton optimization to estimates the
     coefficients of CSTRbasis to minimize the weighted sum of squares
     of residuals returned by CSTRfitLS.  

     CSTRres and CSTRres0 provide alternative interfaces between 'nls'
     and 'CSTRfn'.  Both get the parameters to be estimated via their
     official function arguments, kref, EoverR, a, and / or b.  The
     subset of these paramters to estimate must be specified both
     directly in the function call to 'nls' and indirectly via
     fitstruct[["estimate"]].  CSTRres gets the other CSTRfn arguments
     (datstruct, fitstruct, CSTRbasis, and lambda) via the 'data'
     argument of 'nls'.  (The version of 'nls' in the 'stats' package
     in R 2.5.0 required 'data' to be a data.frame, not merely a list. 
     The version of 'nls' in 'fda' does not require this.) By contrast,
     CSTRres0 uses 'get' to obtain these other arguments as .datstruct,
     .fitstruct, .CSTRbasis and .lambda.  Thus, before calling
     nls(~CSTRres0(...), ...), the values of these arguments must be
     assigned to .datstruct, .fitstruct, .CSTRbasis and .lambda.  If
     'nls' is called from the global environment, it will look for
     these objects in the global environment.

     CSTRres0 has one feature absent from CSTRres:  If a variable
     .CSTRres0.trace is available, it is assumed to be a matrix with
     columns kref, EoverR, a, b, SSE, plus all residuals.  These
     numbers are rbinded as an additional row of this matrix.  This is
     provided to help diagnose a problem were 'nls' was terminating
     with "step factor ... reduced below 'minFactor'", facilitating the
     comparison between R and Matlab for the precise sets of parameter
     values tested by 'nls'.    

     CSTRsse computes sum of squares of residuals for use with optim or
     nlminb.

_V_a_l_u_e:

 CSTR2in: a matrix with number of rows = length(Time) and columns for
          F., CA0, T0, Tcin, and Fc.  This gives the inputs to the CSTR
          simulation for the chosen 'condition'.  

   CSTR2: a list with one component being a matrix with number of rows
          = length(tobs) and 2 columns giving the first derivatives of
          Conc and Temp according to the right hand side of the
          differential equation. CSTR2 calls CSTR2in to get its inputs.            

CSTRfitLS: a list with one or two components as follows:  


        _r_e_s a list with two components

             Sres = a matrix giving the residuals between observed and
             predicted datstruct[["y"]] divided by
             sqrt(datstruct[[c("Cwt", "Twt")]]) so the result is
             dimensionless.  dim(Sres) =   dim(datstruct[["y"]]). 
             Thus, if datstruct[["y"]] has only one column, 'Sres' has
             only one column. 

             Lres = a matrix with two columns giving the difference
             between  left and right hand sides of the CSTR
             differential equation at all the quadrature points. 
             dim(Lres) = c(nquad, 2).  

        _D_r_e_s If gradwrd=TRUE, a list with two components:

             DSres = a matrix with one row for each element of
             res[["Sres"]] and two columns for each basis function.

             DLres = a matrix with two rows for each quadrature point
             and two columns for each basis function.

             If gradwrd=FALSE, this component is not present.  


  CSTRfn: a list with five components:


        _r_e_s the 'res' component of the final 'CSTRfitLS' object
             reformatted with its component Sres first followed by
             Lres, using with(CSTRfitLS(...)[["res"]], c(Sres, Lres)). 

        _D_r_e_s one of two very different gradient matrices depending on
             the value of 'gradwrd'.

             If gradwrd = TRUE, Dres is a matrix with one row for each
             observation value to match and one column for each
             parameter taken from 'parvec' per fitstruct[["estimate"]].
              Also, if fitstruct[["fit"]] = c(1,1), CSTRfn tries to 
             match both Concentration and Temperature, and rows
             corresponding to Concentration come first following by
             rows corresponding to Temperature. 

             If gradwrd = FALSE, this is the 'Dres' component of the
             final 'CSTRfitLS' object reformatted as follows:  

             Dres <- with(CSTRfitLS(...)[["Dres"]], rbind(DSres,
             DLres))

        _f_i_t_s_t_r_u_c_t a list components matching the 'fitstruct' input,
             with coefficients estimated replaced by their initial
             values from parvec and with coef0 replace by its final
             estimate. 

        _d_f estimated degrees of freedom as the trace of the appropriate
             matrix. 

        _g_c_v the Generalized cross validation estimate of the mean
             square error, as discussed in Ramsay and Silverman (2006,
             sec. 5.4).   


CSTRres, CSTRres0: the 'res' component of CSTRfd(...) as a column
          vector.  This allows us to use 'nls' with the CSTR model. 
          This can be especially useful as 'nls' has several helper
          functions to facilitate evaluating goodness of fit and and
          uncertainty in parameter estimates.   

 CSTRsse: sum(res*res) from CSTRfd(...).  This allows us to use 'optim'
          or 'nlminb' with the CSTR model.  This can also be used to
          obtain starting values for 'nls' in cases where 'nls' fails
          to converge from the initiall provided starting values. 
          Apart from 'par', the other arguments 'datstruct',
          'fitstruct', 'CSTRbasis', and 'lambda', must be passed via
          '...' in 'optim' or 'nlminb'.   

_R_e_f_e_r_e_n_c_e_s:

     Ramsay, J. O., Hooker, G., Cao, J. and Campbell, D. (2007)
     Parameter estimation for differential equations: A generalized
     smoothing approach (with discussion). Journal of the Royal
     Statistical Society, Series B. To appear.

     Ramsay, J. O., and Silverman, B. W. (2006) Functional Data
     Analysis, 2nd ed. (Springer)

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York

_S_e_e _A_l_s_o:

     'lsoda' 'nls'

_E_x_a_m_p_l_e_s:

     ###
     ###
     ### 1.  lsoda(y, times, func=CSTR2, parms=...)
     ###
     ###
     #  The system of two nonlinear equations has five forcing or  
     #  input functions.
     #  These equations are taken from
     #  Marlin, T. E. (2000) Process Control, 2nd Edition, McGraw Hill,
     #  pages 899-902.
     ##
     ##  Set up the problem 
     ##
     fitstruct <- list(V    = 1.0,#  volume in cubic meters 
                       Cp   = 1.0,#  concentration in cal/(g.K)
                       rho  = 1.0,#  density in grams per cubic meter 
                       delH = -130.0,# cal/kmol
                       Cpc  = 1.0,#  concentration in cal/(g.K)
                       rhoc = 1.0,#  cal/kmol
                       Tref = 350)#  reference temperature
     #  store true values of known parameters 
     EoverRtru = 0.83301#   E/R in units K/1e4
     kreftru   = 0.4610 #   reference value
     atru      = 1.678#     a in units (cal/min)/K/1e6
     btru      = 0.5#       dimensionless exponent

     #

     fitstruct[["kref"]]   = kreftru#      
     fitstruct[["EoverR"]] = EoverRtru#  kref = 0.4610
     fitstruct[["a"]]      = atru#       a in units (cal/min)/K/1e6
     fitstruct[["b"]]      = btru#       dimensionless exponent
      
     Tlim  = 64#    reaction observed over interval [0, Tlim]
     delta = 1/12#  observe every five seconds
     tspan = seq(0, Tlim, delta)#

     coolStepInput <- CSTR2in(tspan, 'all.cool.step')

     #  set constants for ODE solver

     #  cool condition solution
     #  initial conditions

     Cinit.cool = 1.5965#  initial concentration in kmol per cubic meter
     Tinit.cool = 341.3754# initial temperature in deg K
     yinit = c(Conc = Cinit.cool, Temp=Tinit.cool)

     #  load cool input into fitstruct

     fitstruct[["Tcin"]] = coolStepInput[, "Tcin"];

     #  solve  differential equation with true parameter values

     if (require(odesolve)) {
     coolStepSoln <- lsoda(y=yinit, times=tspan, func=CSTR2,
       parms=list(fitstruct=fitstruct, condition='all.cool.step', Tlim=Tlim) )
     }
     ###
     ###
     ### 2.  CSTRfn 
     ###
     ###

     # See the script in '~R\library\fda\scripts\CSTR\CSTR_demo.R'
     #  for more examples.  

