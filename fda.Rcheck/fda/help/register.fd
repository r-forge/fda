register.fd               package:fda               R Documentation

_R_e_g_i_s_t_e_r _F_u_n_c_t_i_o_n_a_l _D_a_t_a _O_b_j_e_c_t_s _U_s_i_n_g _a _C_o_n_t_i_n_u_o_u_s _C_r_i_t_e_r_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     criterion.  By aligned is meant that the shape of each curve is
     matched as closely as possible to that of the target by means of a
     smooth increasing transformation of the argument, or a warping
     function.

_U_s_a_g_e:

     register.fd(y0fd=NULL, yfd=NULL, WfdParobj=c(Lfdobj=2, lambda=1),
                 conv=1e-04, iterlim=20, dbglev=1, periodic=FALSE, crit=2)

_A_r_g_u_m_e_n_t_s:

    y0fd: a functional data object defining the target for
          registration.

          If 'yfd' is NULL and y0fd is a multivariate data object, then
          y0fd is assigned to yfd and y0fd is replaced by its mean.

          Alternatively, if 'yfd' is a multivariate functional data
          object and y0fd is missing, y0fd is replaced by the mean of
          'y0fd'.  

          Otherwise, y0fd must be a univariate functional data object
          taken as the target to which 'yfd' is registered.   

     yfd: a multivariate functional data object defining the functions
          to be registered to target 'y0fd'.  If it is NULL and 'y0fd'
          is a multivariate functional data object, yfd takes the value
          of  'y0fd'.   

WfdParobj: a functional parameter object for a single function.  This
          is used as the initial value in the estimation of a function
          $W(t)$ that defines the warping function $h(t)$ that
          registers a particular curve. The object also contains
          information on a roughness penalty  and smoothing parameter
          to control the roughness of $h(t)$.

          Alternatively, this can be a vector or a list with components
          named 'Lfdobj' and 'lambda', which are passed as arguments to
          'fdPar' to create the functional parameter form of WfdParobj
          required by the rest of the register.fd algorithm.

          The default 'Lfdobj' of 2 penalizes curvature, thereby
          preferring no warping of time, with 'lambda' indicating the
          strength of that preference.  A common alternative is
          'Lfdobj' = 3, penalizing the rate of change of curvature.    

    conv: a criterion for convergence of the iterations. 

 iterlim: a limit on the number of iterations. 

  dbglev: either 0, 1, or 2.  This controls the amount information
          printed out on each iteration, with 0 implying no output, 1
          intermediate output level, and 2 full output.  (If this is
          run with output buffering such as used with S-Plus, it may be
          necessary to turn off the output buffering to actually get
          the progress reports before the completion of computations.)             

periodic: a logical variable:  if 'TRUE', the functions are considered
          to be periodic, in which case a constant can be added to all
          argument values after they are warped.  

    crit: an integer that is either 1 or 2 that indicates the nature of
          the continuous registration criterion that is used.  If 1,
          the criterion is least squares, and if 2, the criterion is
          the minimum eigenvalue of a cross-product matrix.  In
          general, criterion 2 is to be preferred. 

_D_e_t_a_i_l_s:

     The warping function that smoothly and monotonely transforms the
     argument is defined by 'Wfd' is the same as that defines the
     monotone smoothing function in for function 'smooth.monotone.' See
     the help file for that function for further details.

_V_a_l_u_e:

     a named list of length 3 containing the following components:

   regfd: A functional data object containing the registered functions. 

     Wfd: A functional data object containing the functions $h W(t)$
          that define the warping functions $h(t)$. 

   shift: If the functions are periodic, this is a vector of time
          shifts. 

_S_o_u_r_c_e:

     Ramsay, James O., and Silverman, Bernard W. (2006), _Functional
     Data Analysis, 2nd ed._, Springer, New York.

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York, ch. 6 & 7.

_S_e_e _A_l_s_o:

     'smooth.monotone',  'smooth.morph'

_E_x_a_m_p_l_e_s:

     #See the analyses of the growth data for examples.
     ##
     ## 1.  Simplest call
     ##
     # Specify smoothing weight 
     lambda.gr2.3 <- .03

     # Specify what to smooth, namely the rate of change of curvature
     Lfdobj.growth    <- 2 

     # Establish a B-spline basis
     nage <- length(growth$age)
     norder.growth <- 6
     nbasis.growth <- nage + norder.growth - 2
     rng.growth <- range(growth$age)
     # 1 18 
     wbasis.growth <- create.bspline.basis(rangeval=rng.growth,
                        nbasis=nbasis.growth, norder=norder.growth,
                        breaks=growth$age)

     # Smooth consistent with the analysis of these data
     # in afda-ch06.R, and register to individual smooths:  
     cvec0.growth <- matrix(0,nbasis.growth,1)
     Wfd0.growth  <- fd(cvec0.growth, wbasis.growth)
     growfdPar2.3 <- fdPar(Wfd0.growth, Lfdobj.growth, lambda.gr2.3)
     # Create a functional data object for all the boys
     hgtmfd.all <- with(growth, smooth.basis(age, hgtm, growfdPar2.3))

     nBoys <- 2
     # nBoys <- dim(growth[["hgtm"]])[2]
     # register.fd takes time, so use only 2 curves as an illustration
     # to minimize compute time in this example;  

     #Alternative to subsetting later is to subset now:  
     #hgtmfd.all<-with(growth,smooth.basis(age, hgtm[,1:nBoys],growfdPar2.3))

     # Register the growth velocity rather than the
     # growth curves directly 
     smBv <- deriv(hgtmfd.all$fd, 1)

     # This takes time, so limit the number of curves registered to nBoys

     ## Not run: 
     smB.reg.0 <- register.fd(smBv[1:nBoys])

     smB.reg.1 <- register.fd(smBv[1:nBoys],WfdParobj=c(Lfdobj=Lfdobj.growth, lambda=lambda.gr2.3))

     ##
     ## 2.  Call providing the target
     ##

     smBv.mean <- deriv(mean(hgtmfd.all$fd[1:nBoys]), 1)
     smB.reg.2a <- register.fd(smBv.mean, smBv[1:nBoys],
                    WfdParobj=c(Lfdobj=Lfdobj.growth, lambda=lambda.gr2.3))

     smBv.mean <- mean(smBv[1:nBoys]) 
     smB.reg.2 <- register.fd(smBv.mean, smBv[1:nBoys],
                    WfdParobj=c(Lfdobj=Lfdobj.growth, lambda=lambda.gr2.3))
     all.equal(smB.reg.1, smB.reg.2) 

     ##
     ## 3.  Call using WfdParobj
     ##

     # Create a dummy functional data object
     # to hold the functional data objects for the
     # time warping function
     # ... start with a zero matrix (nbasis.growth, nBoys) 
     smBc0 <- matrix(0, nbasis.growth, nBoys)
     # ... convert to a functional data object 
     smBwfd0 <- fd(smBc0, wbasis.growth)
     # ... convert to a functional parameter object 
     smB.wfdPar <- fdPar(smBwfd0, Lfdobj.growth, lambda.gr2.3)

     smB.reg.3<- register.fd(smBv[1:nBoys], WfdParobj=smB.wfdPar)
     all.equal(smB.reg.1, smB.reg.3)
     ## End(Not run)

