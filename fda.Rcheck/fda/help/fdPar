fdPar                  package:fda                  R Documentation

_D_e_f_i_n_e _a _F_u_n_c_t_i_o_n_a_l _P_a_r_a_m_e_t_e_r _O_b_j_e_c_t

_D_e_s_c_r_i_p_t_i_o_n:

     Functional parameter objects are used as arguments to functions
     that estimate functional parameters, such as smoothing functions
     like 'smooth.basis'.  A functional parameter object is a
     functional data object with additional slots specifying a
     roughness penalty, a smoothing parameter and whether or not the
     functional parameter is to be estimated or held fixed.  Functional
     parameter objects are used as arguments to functions that estimate
     functional parameters.

_U_s_a_g_e:

     fdPar(fdobj=NULL, Lfdobj=NULL, lambda=0, estimate=TRUE, penmat=NULL)

_A_r_g_u_m_e_n_t_s:

   fdobj: a functional data object, functional basis object, a
          functional parameter object or a matrix.  If class(fdobj) ==
          'basisfd', it is converted to an object of class 'fd' with
          the identity matrix as the coefficient matrix.  If it a
          matrix, it is replaced by fd(fdobj). 

  Lfdobj: either a nonnegative integer or a linear differential
          operator object.  If NULL and fdobj[['type']] == 'bspline',
          Lfdobj = int2Lfd(max(0, norder-2)), where norder = order of
          fdobj. 

  lambda: a nonnegative real number specifying the amount of smoothing
          to be applied to the estimated functional parameter. 

estimate: not currently used.

  penmat: a roughness penalty matrix.  Including this can eliminate the
          need to compute this matrix over and over again in some types
          of calculations. 

_D_e_t_a_i_l_s:

     Functional parameters are often needed to specify initial values
     for iteratively refined estimates, as is the case in functions
     'register.fd' and 'smooth.monotone'.

     Often a list of functional parameters must be supplied to a
     function as an argument, and it may be that some of these
     parameters are considered known and must remain fixed during the
     analysis.  This is the case for functions 'fRegress' and 
     'pda.fd', for example.

_V_a_l_u_e:

     a functional parameter object (i.e., an object of class 'fdPar'),
     which is a list with the following components:

      fd: a functional data object (i.e., with class 'fd') 

     Lfd: a linear differential operator object (i.e., with class
          'Lfd') 

  lambda: a nonnegative real number 

estimate: not currently used

  penmat: either NULL or a square, symmetric matrix with penmat[i, j] =
          integral over fd[['basis']][['rangeval']] of
          basis[i]*basis[j] 

     normal-bracket37bracket-normal

_S_o_u_r_c_e:

     Ramsay, James O., and Silverman, Bernard W. (2006), _Functional
     Data Analysis, 2nd ed._, Springer, New York.

     Ramsay, James O., and Silverman, Bernard W. (2002), _Applied
     Functional Data Analysis_, Springer, New York

_S_e_e _A_l_s_o:

     'cca.fd', 'density.fd', 'fRegress', 'intensity.fd', 'pca.fd',
     'smooth.fdPar', 'smooth.basis', 'smooth.basisPar',
     'smooth.monotone', '\line{int2Lfd}'

_E_x_a_m_p_l_e_s:

     ##
     ## Simple example
     ##
     #  set up range for density
     rangeval <- c(-3,3)
     #  set up some standard normal data
     x <- rnorm(50)
     #  make sure values within the range
     x[x < -3] <- -2.99
     x[x >  3] <-  2.99
     #  set up basis for W(x)
     basisobj <- create.bspline.basis(rangeval, 11)
     #  set up initial value for Wfdobj
     Wfd0 <- fd(matrix(0,11,1), basisobj)
     WfdParobj <- fdPar(Wfd0)

     WfdP3 <- fdPar(seq(-3, 3, length=11))

     ##
     ##  smooth the Canadian daily temperature data
     ##
     #    set up the fourier basis
     nbasis   <- 365
     dayrange <- c(0,365)
     daybasis <- create.fourier.basis(dayrange, nbasis)
     dayperiod <- 365
     harmaccelLfd <- vec2Lfd(c(0,(2*pi/365)^2,0), dayrange)
     #  Make temperature fd object
     #  Temperature data are in 12 by 365 matrix tempav
     #    See analyses of weather data.
     #  Set up sampling points at mid days
     daytime  <- (1:365)-0.5
     #  Convert the data to a functional data object
     daybasis65 <- create.fourier.basis(dayrange, nbasis, dayperiod)
     templambda <- 1e1
     tempfdPar  <- fdPar(fdobj=daybasis65, Lfdobj=harmaccelLfd, lambda=templambda)

     #FIXME
     #tempfd <- smooth.basis(CanadianWeather$tempav, daytime, tempfdPar)
     #  Set up the harmonic acceleration operator
     Lbasis  <- create.constant.basis(dayrange);
     Lcoef   <- matrix(c(0,(2*pi/365)^2,0),1,3)
     bfdobj  <- fd(Lcoef,Lbasis)
     bwtlist <- fd2list(bfdobj)
     harmaccelLfd <- Lfd(3, bwtlist)
     #  Define the functional parameter object for
     #  smoothing the temperature data
     lambda   <- 0.01  #  minimum GCV estimate
     #tempPar <- fdPar(daybasis365, harmaccelLfd, lambda)
     #  smooth the data
     #tempfd <- smooth.basis(daytime, CanadialWeather$tempav, tempPar)$fd
     #  plot the temperature curves
     #plot(tempfd)

