cor.fd                  package:fda                  R Documentation

_C_o_r_r_e_l_a_t_i_o_n _m_a_t_r_i_x _f_r_o_m _f_u_n_c_t_i_o_n_a_l _d_a_t_a _o_b_j_e_c_t(_s)

_D_e_s_c_r_i_p_t_i_o_n:

     Compute a correlation matrix for one or two functional data
     objects.

_U_s_a_g_e:

     cor.fd(evalarg1, fdobj1, evalarg2=evalarg1, fdobj2=fdobj1)

_A_r_g_u_m_e_n_t_s:

evalarg1: a vector of argument values for fdobj1.    

evalarg2: a vector of argument values for fdobj2.   

fdobj1, fdobj2: functional data objects  

_D_e_t_a_i_l_s:

     1.  var1 <- var.fd(fdobj1) 

     2.  evalVar1 <- eval.bifd(evalarg1, evalarg1, var1)

     3.  if(missing(fdobj2)) Convert evalVar1 to correlations

     4.  else:  

     4.1.  var2 <- var.fd(fdobj2)

     4.2.  evalVar2 <- eval.bifd(evalarg2, evalarg2, var2)

     4.3.  var12 <- var.df(fdobj1, fdobj2)

     4.4.  evalVar12 <- eval.bifd(evalarg1, evalarg2, var12)

     4.5.  Convert evalVar12 to correlations

_V_a_l_u_e:

     A matrix or array:

     With one or two functional data objects, fdobj1 and possibly
     fdobj2, the value is a matrix of dimensions length(evalarg1) by
     length(evalarg2) giving the correlations at those points of fdobj1
     if missing(fdojb2) or of correlations between eval.fd(evalarg1,
     fdobj1) and eval.fd(evalarg2, fdobj2).

     With a single multivariate data object with k variables, the value
     is a 4-dimensional array of dim = c(nPts, nPts, 1, choose(k+1,
     2)), where nPts = length(evalarg1).

_S_e_e _A_l_s_o:

     'mean.fd',  'sd.fd',  'std.fd' 'stdev.fd' 'var.fd'

_E_x_a_m_p_l_e_s:

     daybasis3 <- create.fourier.basis(c(0, 365))
     daybasis5 <- create.fourier.basis(c(0, 365), 5)
     tempfd3 <- with(CanadianWeather, data2fd(
            dailyAv[,,"Temperature.C"], day.5,
            daybasis3, argnames=list("Day", "Station", "Deg C")) )
     precfd5 <- with(CanadianWeather, data2fd(
            dailyAv[,,"log10precip"], day.5,
            daybasis5, argnames=list("Day", "Station", "Deg C")) )

     # Correlation matrix for a single functional data object
     (tempCor3 <- cor.fd(seq(0, 356, length=4), tempfd3))

     # Cross correlation matrix between two functional data objects 
     # Compare with structure described above under 'value':
     (tempPrecCor3.5 <- cor.fd(seq(0, 365, length=4), tempfd3,
                               seq(0, 356, length=6), precfd5))

     # The following produces contour and perspective plots

     daybasis65 <- create.fourier.basis(rangeval=c(0, 365), nbasis=65)
     daytempfd <- with(CanadianWeather, data2fd(
            dailyAv[,,"Temperature.C"], day.5,
            daybasis65, argnames=list("Day", "Station", "Deg C")) )
     dayprecfd <- with(CanadianWeather, data2fd(
            dailyAv[,,"log10precip"], day.5,
            daybasis65, argnames=list("Day", "Station", "log10(mm)")) )

     str(tempPrecCor <- cor.fd(weeks, daytempfd, weeks, dayprecfd))
     # dim(tempPrecCor)= c(53, 53)

     op <- par(mfrow=c(1,2), pty="s")
     contour(weeks, weeks, tempPrecCor, 
             xlab="Average Daily Temperature",
             ylab="Average Daily log10(precipitation)",
             main=paste("Correlation function across locations\n",
               "for Canadian Anual Temperature Cycle"),
             cex.main=0.8, axes=FALSE)
     axisIntervals(1, atTick1=seq(0, 365, length=5), atTick2=NA, 
                 atLabels=seq(1/8, 1, 1/4)*365,
                 labels=paste("Q", 1:4) )
     axisIntervals(2, atTick1=seq(0, 365, length=5), atTick2=NA, 
                 atLabels=seq(1/8, 1, 1/4)*365,
                 labels=paste("Q", 1:4) )
     persp(weeks, weeks, tempPrecCor,
           xlab="Days", ylab="Days", zlab="Correlation")
     mtext("Temperature-Precipitation Correlations", line=-4, outer=TRUE)
     par(op)

     # Correlations and cross correlations
     # in a bivariate functional data object
     gaitbasis5 <- create.fourier.basis(nbasis=5)
     gaitfd5 <- data2fd(gait, basisobj=gaitbasis5)

     gait.t3 <- (0:2)/2
     (gaitCor3.5 <- cor.fd(gait.t3, gaitfd5))
     # Check the answers with manual computations
     gait3.5 <- eval.fd(gait.t3, gaitfd5)
     all.equal(cor(t(gait3.5[,,1])), gaitCor3.5[,,,1])
     # TRUE
     all.equal(cor(t(gait3.5[,,2])), gaitCor3.5[,,,3])
     # TRUE
     all.equal(cor(t(gait3.5[,,2]), t(gait3.5[,,1])),
                    gaitCor3.5[,,,2])
     # TRUE

     # NOTE:
     dimnames(gaitCor3.5)[[4]]
     # [1] Hip-Hip
     # [2] Knee-Hip 
     # [3] Knee-Knee
     # If [2] were "Hip-Knee", then
     # gaitCor3.5[,,,2] would match 
     # cor(t(gait3.5[,,1]), t(gait3.5[,,2]))
     # *** It does NOT.  Instead, it matches:  
     # cor(t(gait3.5[,,2]), t(gait3.5[,,1]))

