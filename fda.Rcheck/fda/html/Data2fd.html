<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Create a functional data object from data</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for Data2fd {fda}"><tr><td>Data2fd {fda}</td><td align="right">R Documentation</td></tr></table>
<h2>Create a functional data object from data</h2>


<h3>Description</h3>

<p>
This function converts an array <code>y</code> of function values plus an
array <code>argvals</code> of argument values into a functional data object.
This function tries to do as much for the user as possible.  NOTE:
Interpolation with data2fd(...) can be shockingly bad, as illustrated
in one of the examples.
</p>


<h3>Usage</h3>

<pre>
Data2fd(argvals=NULL, y=NULL, basisobj=NULL, nderiv=NULL,
        lambda=0, fdnames=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>argvals</code></td>
<td>
a set of argument values.  If this is a vector, the same set of
argument values is used for all columns of <code>y</code>.  If
<code>argvals</code> is a matrix, the columns correspond to the columns of
<code>y</code>, and contain the argument values for that replicate or
case.
<br>
Dimensions for <code>argvals</code> must match the first dimensions of
<code>y</code>, though <code>y</code> can have more dimensions.  For example, if
dim(y) = c(9, 5, 2), <code>argvals</code> can be a vector of length 9 or a
matrix of dimenions c(9, 5) or an array of dimensions c(9, 5, 2).  
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
an array containing sampled values of curves.
<br>
If <code>y</code> is a vector, only one replicate and variable are
assumed.  If <code>y</code> is a matrix, rows must correspond to argument 
values and columns to replications or cases, and it will be assumed
that there is only one variable per observation.  If <code>y</code> is a
three-dimensional array, the first dimension (rows) corresponds to
argument values, the second (columns) to replications, and the third
(layers) to variables within replications.  Missing values are
permitted, and the number of values may vary from one replication to
another.  If this is the case, the number of rows must equal the
maximum number of argument values, and columns of <code>y</code> having
fewer values must be padded out with NA's.   
</td></tr>
<tr valign="top"><td><code>basisobj</code></td>
<td>
One of the following:
<br>
<ul>
<dt>basisfd</dt><dd>a functional basis object (class <code>basisfd</code>). 
</dd>
<dt>fd</dt><dd>a functional data object (class <code>fd</code>), from which its
<code>basis</code> component is extracted.  
</dd>
<dt>fdPar</dt><dd>a functional parameter object (class <code>fdPar</code>), from which
its <code>basis</code> component is extracted.  
</dd>
<dt>integer</dt><dd>an integer giving the order of a B-spline basis,
create.bspline.basis(argvals, norder=basisobj) 
</dd>
<dt>numeric vector</dt><dd>specifying the knots for a B-spline basis,
create.bspline.basis(basisobj) 
</dd>         
<dt>NULL</dt><dd>Defaults to create.bspline.basis(argvals).
</dd>
</ul>
</td></tr>
<tr valign="top"><td><code>nderiv</code></td>
<td>
Smoothing typically specified as an integer order for the derivative
whose square is integrated and weighted by <code>lambda</code> to smooth.
By default, if basisobj[['type']] == 'bspline', the smoothing
operator is int2Lfd(max(0, norder-2)).
<br>
A general linear differential operator can also be supplied.  
</td></tr>
<tr valign="top"><td><code>lambda</code></td>
<td>
weight on the smoothing operator specified by <code>nderiv</code>.  
</td></tr>
<tr valign="top"><td><code>fdnames</code></td>
<td>
Either a charater vector of length 3 or a named list of length 3.
In either case, the three elements correspond to the following:  
<br>
<ul>
<dt>argname</dt><dd>name of the argument, e.g. "time" or "age".  
</dd>
<dt>repname</dt><dd>a description of the cases, e.g. "reps" or "weather stations"
</dd>
<dt>value</dt><dd>the name of the observed function value, e.g. "temperature"
</dd>
</ul>
<br>
If fdnames is a list, the components provide labels for the levels
of the corresponding dimension of <code>y</code>.  
</td></tr>
</table>

<h3>Details</h3>

<p>
This function tends to be used in rather simple applications where
there is no need to control the roughness of the resulting curve with
any great finesse.  The roughness is essentially controlled by how
many basis functions are used.  In more sophisticated applications, it
would be better to use the function <code><a href="smooth.basisPar.html">smooth.basisPar</a></code>.
</p>


<h3>Value</h3>

<p>
an object of the <code>fd</code> class containing:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>coefs</code></td>
<td>
the coefficient array
</td></tr>
<tr valign="top"><td><code>basis</code></td>
<td>
a basis object 
</td></tr>
<tr valign="top"><td><code>fdnames</code></td>
<td>
a list containing names for the arguments, function values
and variables
</td></tr>
</table>

<h3>References</h3>

<p>
Ramsay, James O., and Silverman, Bernard W. (2005), <EM>Functional 
Data Analysis, 2nd ed.</EM>, Springer, New York. 
</p>
<p>
Ramsay, James O., and Silverman, Bernard W. (2002), <EM>Applied
Functional Data Analysis</EM>, Springer, New York.
</p>


<h3>See Also</h3>

<p>
<code><a href="smooth.basisPar.html">smooth.basisPar</a></code>, 
<code><a href="smooth.basis.html">smooth.basis</a></code>, 
<code><a href="project.basis.html">project.basis</a></code>, 
<code><a href="smooth.fd.html">smooth.fd</a></code>, 
<code><a href="smooth.monotone.html">smooth.monotone</a></code>, 
<code><a href="smooth.pos.html">smooth.pos</a></code>
<code><a href="dateAccessories.html">day.5</a></code>
</p>


<h3>Examples</h3>

<pre>
##
## Simplest possible example:  step function 
##
b1.1 &lt;- create.bspline.basis(nbasis=1, norder=1)
# 1 basis, order 1 = degree 0 = step function

y12 &lt;- 1:2
fd1.1 &lt;- Data2fd(y12, basisobj=b1.1)
plot(fd1.1)
# fd1.1 = mean(y12) = 1.5 

fd1.1.5 &lt;- Data2fd(y12, basisobj=b1.1, lambda=0.5)
eval.fd(seq(0, 1, .2), fd1.1.5)
# fd1.1.5 = sum(y12)/(n+lambda*integral(over arg=0 to 1 of 1))
#         = 3 / (2+0.5) = 1.2

##
## 3 step functions
##
b1.2 &lt;- create.bspline.basis(nbasis=2, norder=1)
# 2 bases, order 1 = degree 0 = step functions
fd1.2 &lt;- Data2fd(1:2, basisobj=b1.2)

op &lt;- par(mfrow=c(2,1))
plot(b1.2, main='bases') 
plot(fd1.2, main='fit')
par(op) 
# A step function:  1 to 0.5, then 2 

##
## Simple oversmoothing
##
b1.3 &lt;- create.bspline.basis(nbasis=3, norder=1)
fd1.3.5 &lt;- Data2fd(y12, basisobj=b1.3, lambda=0.5)
plot(0:1, c(0, 2), type='n')
points(0:1, y12)
lines(fd1.3.5)
# Fit = penalized least squares with penalty = 
#          = lambda * integral(0:1 of basis^2),
#            which shrinks the points towards 0.
# X1.3 = matrix(c(1,0, 0,0, 0,1), 2)
# XtX = crossprod(X1.3) = diag(c(1, 0, 1))
# penmat = diag(3)/3
#        = 3x3 matrix of integral(over arg=0:1 of basis[i]*basis[j])
# Xt.y = crossprod(X1.3, y12) = c(1, 0, 2)
# XtX + lambda*penmat = diag(c(7, 1, 7)/6 
# so coef(fd1.3.5) = solve(XtX + lambda*penmat, Xt.y)
#                  = c(6/7, 0, 12/7)

##
## linear spline fit 
##
b2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0, .5, 1))
# 3 bases, order 2 = degree 1 =
# continuous, bounded, locally linear

fd2.3 &lt;- Data2fd(0:1, basisobj=b2.3)
round(fd2.3$coefs, 4)
# (0, 0, 1), 
# though (0, a, 1) is also a solution for any 'a' 
op &lt;- par(mfrow=c(2,1))
plot(b2.3, main='bases') 
plot(fd2.3, main='fit')
par(op)

# smoothing?  
fd2.3. &lt;- Data2fd(0:1, basisobj=b2.3, lambda=1)

all.equal(as.vector(round(fd2.3.$coefs, 4)),
          c(0.0159, -0.2222, 0.8730) )

# The default smoothing with spline of order 2, degree 1
# has nderiv = max(0, norder-2) = 0.
# Direct computations confirm that the optimal B-spline
# weights in this case are the numbers given above.  

op &lt;- par(mfrow=c(2,1))
plot(b2.3, main='bases') 
plot(fd2.3., main='fit')
par(op)

##
## quadratic spline fit
##
b3.4 &lt;- create.bspline.basis(norder=3, breaks=c(0, .5, 1))
# 4 bases, order 3 = degree 2 =
# continuous, bounded, locally quadratic 

fd3.4 &lt;- Data2fd(0:1, basisobj=b3.4)
round(fd3.4$coefs, 4)
# (0, 0, 0, 1),
# but (0, a, b, 1) is also a solution for any 'a' and 'b' 
op &lt;- par(mfrow=c(2,1))
plot(b3.4) 
plot(fd3.4)
par(op)

#  try smoothing?  
fd3.4. &lt;- Data2fd(0:1, basisobj=b3.4, lambda=1)
round(fd3.4.$coef, 4)

op &lt;- par(mfrow=c(2,1))
plot(b3.4) 
plot(fd3.4.)
par(op)

##
##  A simple Fourier example 
##
gaitbasis3 &lt;- create.fourier.basis(nbasis=3)
# note:  'names' for 3 bases
gaitfd3 &lt;- Data2fd(gait, basisobj=gaitbasis3)
# Note: dimanes for 'coefs' + basis[['names']]
# + 'fdnames'

#    set up the fourier basis
daybasis &lt;- create.fourier.basis(c(0, 365), nbasis=65)
#  Make temperature fd object
#  Temperature data are in 12 by 365 matrix tempav
#    See analyses of weather data.

#  Convert the data to a functional data object
tempfd &lt;- Data2fd(CanadianWeather$dailyAv[,,"Temperature.C"],
                  day.5, daybasis)
#  plot the temperature curves
plot(tempfd)

##
## Terrifying interpolation
##
hgtbasis &lt;- with(growth, create.bspline.basis(range(age), 
                                              breaks=age, norder=6))
girl.data2fd &lt;- with(growth, Data2fd(hgtf, age, hgtbasis))
age2 &lt;- with(growth, sort(c(age, (age[-1]+age[-length(age)])/2)))
girlPred &lt;- eval.fd(age2, girl.data2fd)
range(growth$hgtf)
range(growth$hgtf-girlPred[seq(1, by=2, length=31),])
# 5.5e-6 0.028 &lt;
# The predictions are consistently too small
# but by less than 0.05 percent 

matplot(age2, girlPred, type="l")
with(growth, matpoints(age, hgtf))
# girl.data2fd fits the data fine but goes berzerk
# between points

# Smooth 
girl.data2fd1 &lt;- with(growth, Data2fd(age, hgtf, hgtbasis, lambda=1))
girlPred1 &lt;- eval.fd(age2, girl.data2fd1)

matplot(age2, girlPred1, type="l")
with(growth, matpoints(age, hgtf))

# problems splikes disappear 

</pre>



<hr><div align="center">[Package <em>fda</em> version 2.0.5 <a href="00Index.html">Index]</a></div>

</body></html>
