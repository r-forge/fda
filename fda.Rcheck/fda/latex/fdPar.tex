\HeaderA{fdPar}{Define a Functional Parameter Object}{fdPar}
\keyword{smooth}{fdPar}
\begin{Description}\relax
Functional parameter objects are used as arguments to functions that
estimate functional parameters, such as smoothing functions like
\code{smooth.basis}.  A functional parameter object is a functional
data object with additional slots specifying a roughness penalty, a
smoothing parameter and whether or not the functional parameter is to
be estimated or held fixed.  Functional parameter objects are used as
arguments to functions that estimate functional parameters.
\end{Description}
\begin{Usage}
\begin{verbatim}
fdPar(fdobj=NULL, Lfdobj=NULL, lambda=0, estimate=TRUE, penmat=NULL)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{fdobj}] a functional data object, functional basis object, a functional
parameter object or a matrix.  If class(fdobj) == 'basisfd', it is
converted to functional data objects with the identity matrix as the
coefficient matrix.  If it a matrix, it is replaced by fd(fdobj).      

\item[\code{Lfdobj}] either a nonnegative integer or a linear differential operator
object.  If NULL and fdobj[['type']] == 'bspline', Lfdobj =
int2Lfd(max(0, norder-2)), where norder = order of fdobj.   

\item[\code{lambda}] a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.

\item[\code{estimate}] a logical value:  if \code{TRUE}, the functional parameter is
estimated, otherwise, it is held fixed.

\item[\code{penmat}] a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Functional parameters are often needed to specify initial
values for iteratively refined estimates, as is the case in
functions \code{register.fd} and \code{smooth.monotone}.

Often a list of functional parameters must be supplied to a function
as an argument, and it may be that some of these parameters are
considered known and must remain fixed during the analysis.  This is
the case for functions \code{fRegress} and  \code{pda.fd}, for
example.
\end{Details}
\begin{Value}
a functional parameter object
\end{Value}
\begin{Source}\relax
Ramsay, James O., and Silverman, Bernard W. (2006), \emph{Functional
Data Analysis, 2nd ed.}, Springer, New York.

Ramsay, James O., and Silverman, Bernard W. (2002), \emph{Applied
Functional Data Analysis}, Springer, New York
\end{Source}
\begin{SeeAlso}\relax
\code{\LinkA{cca.fd}{cca.fd}}, 
\code{\LinkA{density.fd}{density.fd}}, 
\code{\LinkA{fRegress}{fRegress}}, 
\code{\LinkA{intensity.fd}{intensity.fd}}, 
\code{\LinkA{pca.fd}{pca.fd}}, 
\code{\LinkA{smooth.fdPar}{smooth.fdPar}}, 
\code{\LinkA{smooth.basis}{smooth.basis}}, 
\code{\LinkA{smooth.basisPar}{smooth.basisPar}}, 
\code{\LinkA{smooth.monotone}{smooth.monotone}},
\code{\bsl{}line\{int2Lfd\}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
##
## Simple example
##
#  set up range for density
rangeval <- c(-3,3)
#  set up some standard normal data
x <- rnorm(50)
#  make sure values within the range
x[x < -3] <- -2.99
x[x >  3] <-  2.99
#  set up basis for W(x)
basisobj <- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 <- fd(matrix(0,11,1), basisobj)
WfdParobj <- fdPar(Wfd0)

WfdP3 <- fdPar(seq(-3, 3, length=11))

##
##  smooth the Canadian daily temperature data 
##
#    set up the fourier basis
nbasis   <- 365
dayrange <- c(0,365)
daybasis <- create.fourier.basis(dayrange, nbasis)
dayperiod <- 365
harmaccelLfd <- vec2Lfd(c(0,(2*pi/365)^2,0), dayrange)
#  Make temperature fd object
#  Temperature data are in 12 by 365 matrix tempav
#    See analyses of weather data.
#  Set up sampling points at mid days
daytime  <- (1:365)-0.5
#  Convert the data to a functional data object
daybasis65 <- create.fourier.basis(dayrange, nbasis, dayperiod)
templambda <- 1e1
tempfdPar  <- fdPar(fdobj=daybasis65, Lfdobj=harmaccelLfd, lambda=templambda)

#FIXME
#tempfd <- smooth.basis(CanadianWeather$tempav, daytime, tempfdPar)
#  Set up the harmonic acceleration operator
Lbasis  <- create.constant.basis(dayrange);
Lcoef   <- matrix(c(0,(2*pi/365)^2,0),1,3)
bfdobj  <- fd(Lcoef,Lbasis)
bwtlist <- fd2list(bfdobj)
harmaccelLfd <- Lfd(3, bwtlist)
#  Define the functional parameter object for
#  smoothing the temperature data
lambda   <- 0.01  #  minimum GCV estimate
#tempPar <- fdPar(daybasis365, harmaccelLfd, lambda)
#  smooth the data
#tempfd <- smooth.basis(daytime, CanadialWeather$tempav, tempPar)$fd
#  plot the temperature curves
#plot(tempfd)

\end{ExampleCode}
\end{Examples}

