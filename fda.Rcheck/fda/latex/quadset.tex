\HeaderA{quadset}{Quadrature points and weights for Simpson's rule}{quadset}
\keyword{smooth}{quadset}
\begin{Description}\relax
Set up quadrature points and weights for Simpson's rule.
\end{Description}
\begin{Usage}
\begin{verbatim}
quadset(nquad=5, basisobj=NULL, breaks) 
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{nquad}] an odd integer at least 5 giving the number of evenly spaced
Simpson's rule quadrature points to use over each interval
(breaks[i], breaks[i+1]). 

\item[\code{basisobj}] the basis object that will contain the quadrature points and weights

\item[\code{breaks}] optional interval boundaries.  If this is provided, the first value
must be the initial point of the interval over which the basis is
defined, and the final value must be the end point.  If this is not
supplied, and 'basisobj' is of type 'bspline', the knots are used as
these values.

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Set up quadrature points and weights for Simpson's rule and store
information in the output 'basisobj'.  Simpson's rule is used to
integrate a function between successive values in vector 'breaks'.
That is, over each interval (breaks[i], breaks[i+1]).  Simpson's rule
uses 'nquad' equally spaced quadrature points over this interval,
starting with the the left boundary and ending with the right
boundary.  The quadrature weights are the values
delta*c(1,4,2,4,2,4,..., 2,4,1) where 'delta' is the difference
between successive quadrature points, that is, delta =
(breaks[i-1]-breaks[i])/(nquad-1).
\end{Details}
\begin{Value}
If is.null(basisobj), quadset returns a 'quadvals' matrix with columns
quadpts and quadwts.  Otherwise, it returns basisobj with the
two components set as follows:   

\begin{ldescription}
\item[\code{quadvals}] cbind(quadpts=quadpts, quadwts=quadwts)    

\item[\code{value}] a list with two components containing eval.basis(quadpts, basisobj,
ival-1) for ival=1, 2.  

\end{ldescription}
\end{Value}
\begin{SeeAlso}\relax
\code{\LinkA{create.bspline.basis}{create.bspline.basis}}
\code{\LinkA{eval.basis}{eval.basis}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
(qs7.1 <- quadset(nquad=7, breaks=c(0, .3, 1)))
# cbind(quadpts=c(seq(0, 0.3, length=7),
#              seq(0.3, 1, length=7)), 
#    quadwts=c((0.3/18)*c(1, 4, 2, 4, 2, 4, 1),
#              (0.7/18)*c(1, 4, 2, 4, 2, 4, 1) ) )

# The simplest basis currently available with this function:
bspl2.2 <- create.bspline.basis(norder=2, breaks=c(0,.5, 1))

bspl2.2a <- quadset(basisobj=bspl2.2)
bspl2.2a$quadvals
# cbind(quadpts=c((0:4)/8, .5+(0:4)/8),
#       quadwts=rep(c(1,4,2,4,1)/24, 2) )
bspl2.2a$values
# a list of length 2
# [[1]] = matrix of dimension c(10, 3) with the 3 basis 
#      functions evaluated at the 10 quadrature points:
# values[[1]][, 1] = c(1, .75, .5, .25, rep(0, 6))
# values[[1]][, 2] = c(0, .25, .5, .75, 1, .75, .5, .25, 0)
# values[[1]][, 3] = values[10:1, 1]
#
# values[[2]] = matrix of dimension c(10, 3) with the
#     first derivative of values[[1]], being either 
#    -2, 0, or 2.  
\end{ExampleCode}
\end{Examples}

