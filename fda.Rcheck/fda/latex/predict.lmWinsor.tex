\HeaderA{predict.lmWinsor}{Predict method for Winsorized linear model fits}{predict.lmWinsor}
\keyword{models}{predict.lmWinsor}
\begin{Description}\relax
Model predictions for object of class 'lmWinsor'.
\end{Description}
\begin{Usage}
\begin{verbatim}
## S3 method for class 'lmWinsor':
predict(object, newdata, se.fit = FALSE,
     scale = NULL, df = Inf, 
     interval = c("none", "confidence", "prediction"),
     level = 0.95, type = c("response", "terms"), 
     terms = NULL, na.action = na.pass,
     pred.var = res.var/weights, weights = 1, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{ object }] Object of class inheriting from 'lmWinsor'  

\item[\code{ newdata }] An optional data frame in which to look for variables with which to
predict.  If omitted, the fitted values are used. 

\item[\code{ se.fit}] a switch indicating if standard errors of predictions are required 

\item[\code{ scale }] Scale parameter for std.err. calculation  

\item[\code{df}] degrees of freedom for scale 

\item[\code{interval}] type of prediction (response or model term) 

\item[\code{ level }] Tolerance/confidence level 
\item[\code{ type }] Type of prediction (response or model term);  see
\LinkA{predict.lm}{predict.lm} 

\item[\code{terms}] If 'type="terms"', which terms (default is all terms)

\item[\code{na.action}] function determining what should be done with missing values in
'newdata'.  The default is to predict 'NA'. 

\item[\code{ pred.var }] the variance(s) for future observations to be assumed for prediction
intervals.  See \LinkA{predict.lm}{predict.lm} 'Details'.

\item[\code{ weights }] variance weights for prediction. This can be a numeric vector or a
one-sided model formula. In the latter case, it is interpreted as an
expression evaluated in 'newdata'

\item[\code{...}] additional arguments for other methods

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
1.  Identify inputs and outputs via mdly <- mdlx <- formula(object);
mdly[[3]] <- NULL;  mdlx[[2]] <- NULL;  xNames <- all.vars(mdlx);
yNames <- all.vars(mdly).  Give an error if as.character(mdly[[2]]) !=
yNames.  

2.  If 'newdata' are provided, clip all xNames to (object[["lower"]],
object[["upper"]]). 

3.  Call \LinkA{predict.lm}{predict.lm}  

4.  Clip the responses to the relevant components of
(object[["lower"]], object[["upper"]]).

5.  Done.
\end{Details}
\begin{Value}
'predict.lmWinsor' produces a vector of predictions or a matrix of
predictions with limits or a list, as produced by
\LinkA{predict.lm}{predict.lm}
\end{Value}
\begin{Author}\relax
Spencer Graves
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{lmWinsor}{lmWinsor}}
\code{\LinkA{predict.lm}{predict.lm}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# example from 'anscombe' 
lm.1 <- lmWinsor(y1~x1, data=anscombe)

newD <- data.frame(x1=seq(1, 22, .1))
predW <- predict(lm.1, newdata=newD) 
plot(y1~x1, anscombe, xlim=c(1, 22)) 
lines(newD[["x1"]], predW, col='blue')
abline(h=lm.1[['lower']]['y1'], col='red', lty='dashed') 
abline(h=lm.1[['upper']]['y1'], col='red', lty='dashed')
abline(v=lm.1[['lower']]['x1'], col='green', lty='dashed') 
abline(v=lm.1[['upper']]['x1'], col='green', lty='dashed') 

\end{ExampleCode}
\end{Examples}

