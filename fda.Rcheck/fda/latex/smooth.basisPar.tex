\HeaderA{smooth.basisPar}{Smooth Data Using a Directly Specified Roughness Penalty}{smooth.basisPar}
\keyword{smooth}{smooth.basisPar}
\begin{Description}\relax
Smooth (argvals, y) data with roughness penalty defined by the
remaining arguments.
\end{Description}
\begin{Usage}
\begin{verbatim}
smooth.basisPar(argvals, y, fdobj=NULL, Lfdobj=NULL,
      lambda=0, estimate=TRUE, penmat=NULL,
      wtvec=rep(1, length(argvals)), fdnames=NULL)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{argvals}] a vector of argument values correspond to the observations in array
\code{y}.

\item[\code{y}] an array containing values of curves at discrete sampling points or
argument values. If the array is a matrix, the rows must correspond
to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
\code{y} is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.  If \code{y} is a vector,
only one replicate and variable are assumed.  

\item[\code{fdobj}] One of the following:

\Itemize{
\item[fd] a functional data object (class \code{fd})

\item[basisfd] a functional basis object (class \code{basisfd}), which is
converted to a functional data object with the identity matrix
as the coefficient matrix. 

\item[fdPar] a functional parameter object (class \code{fdPar})

\item[integer] an integer giving the order of a B-spline basis, which is
further converted to a functional data object with the identity
matrix as the coefficient matrix.  

\item[matrix or array] replaced by fd(fdobj)     
\item[NULL] Defaults to fdobj = create.bspline.basis(argvals).

}

\item[\code{Lfdobj}] either a nonnegative integer or a linear differential operator
object.  If NULL and fdobj[['type']] == 'bspline', Lfdobj =
int2Lfd(max(0, norder-2)), where norder = order of fdobj.   

\item[\code{lambda}] a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.

\item[\code{estimate}] a logical value:  if \code{TRUE}, the functional parameter is
estimated, otherwise, it is held fixed.

\item[\code{penmat}] a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.

\item[\code{wtvec}] a vector of the same length as \code{argvals} containing weights for
the values to be smoothed. 

\item[\code{fdnames}] a list of length 3 containing character vectors of names for the
following: 

\Itemize{
\item[args] name for each observation or point in time at which data are
collected for each 'rep', unit or subject.

\item[reps] name for each 'rep', unit or subject.

\item[fun] name for each 'fun' or (response) variable measured repeatedly
(per 'args') for each 'rep'.

}

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
1.  if(is.null(fdobj))fdobj <- create.bspline.basis(argvals).  Else
if(is.integer(fdobj)) fdobj <- create.bspline.basis(argvals, norder =
fdobj) 

2.  fdPar

3.  smooth.basis
\end{Details}
\begin{Value}
The output of a call to 'smooth.basis', which is a named list of
length 6 and class \code{fdSmooth} with the following components:  

\begin{ldescription}
\item[\code{fd}] a functional data object that smooths the data.

\item[\code{df}] a degrees of freedom measure of the smooth

\item[\code{gcv}] the value of the generalized cross-validation or GCV criterion.  If
there are multiple curves, this is a vector of values, one per
curve.  If the smooth is multivariate, the result is a matrix of gcv
values, with columns corresponding to variables.  

\item[\code{SSE}] the error sums of squares.  SSE is a vector or a matrix of the same
size as 'gcv'. 

\item[\code{penmat}] the penalty matrix.

\item[\code{y2cMap}] the matrix mapping the data to the coefficients.

\end{ldescription}
\end{Value}
\begin{References}\relax
Ramsay, James O., and Silverman, Bernard W. (2005), \emph{Functional 
Data Analysis, 2nd ed.}, Springer, New York. 

Ramsay, James O., and Silverman, Bernard W. (2002), \emph{Applied
Functional Data Analysis}, Springer, New York.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Data2fd}{Data2fd}}, 
\code{\LinkA{df2lambda}{df2lambda}}, 
\code{\LinkA{fdPar}{fdPar}}, 
\code{\LinkA{lambda2df}{lambda2df}}, 
\code{\LinkA{lambda2gcv}{lambda2gcv}}, 
\code{\LinkA{plot.fd}{plot.fd}}, 
\code{\LinkA{project.basis}{project.basis}}, 
\code{\LinkA{smooth.basis}{smooth.basis}}, 
\code{\LinkA{smooth.fd}{smooth.fd}}, 
\code{\LinkA{smooth.monotone}{smooth.monotone}}, 
\code{\LinkA{smooth.pos}{smooth.pos}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
##
## simplest call
##
girlGrowthSm <- with(growth, smooth.basisPar(argvals=age, y=hgtf))
plot(girlGrowthSm$fd, xlab="age", ylab="height (cm)",
         main="Girls in Berkeley Growth Study" )
plot(deriv(girlGrowthSm$fd), xlab="age", ylab="growth rate (cm / year)",
         main="Girls in Berkeley Growth Study" )
plot(deriv(girlGrowthSm$fd, 2), xlab="age",
        ylab="growth acceleration (cm / year^2)",
        main="Girls in Berkeley Growth Study" )
#  Shows the effects of smoothing
#  where the size of the third derivative is penalized.
#  The null space contains quadratic functions.

##
## Another simple call
##
lipSm <- smooth.basisPar(liptime, lip)
plot(lipSm)
# oversmoothing
plot(smooth.basisPar(liptime, lip, lambda=1e-9))
# more sensible 

##
## A third example 
##

x <- seq(-1,1,0.02)
y <- x + 3*exp(-6*x^2) + sin(1:101)/2
# sin not rnorm to make it easier to compare
# results across platforms 

#  set up a saturated B-spline basis
basisobj101 <- create.bspline.basis(x)
fdParobj101 <- fdPar(basisobj101, 2, lambda=1)
result101  <- smooth.basis(x, y, fdParobj101)

resultP <- smooth.basisPar(argvals=x, y=y, fdobj=basisobj101, lambda=1)

all.equal(result101, resultP)

# TRUE 

result4 <- smooth.basisPar(argvals=x, y=y, fdobj=4, lambda=1)

all.equal(resultP, result4)

# TRUE 

result4. <- smooth.basisPar(argvals=x, y=y, lambda=1)

all.equal(resultP, result4.)

# TRUE

with(result4, c(df, gcv)) #  display df and gcv measures

result4.4 <- smooth.basisPar(argvals=x, y=y, lambda=1e-4)
with(result4.4, c(df, gcv)) #  display df and gcv measures
# less smoothing, more degrees of freedom, better fit 

plot(result4.4)
lines(result4, col='green')
lines(result4$fd, col='green') # same as lines(result4, ...)

result4.0 <- smooth.basisPar(x, y, basisobj101, lambda=0)

result4.0a <- smooth.basisPar(x, y, lambda=0)

all.equal(result4.0, result4.0a)


with(result4.0, c(df, gcv)) #  display df and gcv measures
# no smoothing, degrees of freedom = number of points 
# but generalized cross validation = Inf
# suggesting overfitting.  

##
## fdnames?
##
girlGrow12 <- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
              fdnames=c('age', 'girl', 'height')) ) 
girlGrow12. <- with(growth, smooth.basisPar(argvals=age, y=hgtf[, 1:2],
    fdnames=list(age=age, girl=c('Carol', 'Sally'), value='height')) )

\end{ExampleCode}
\end{Examples}

